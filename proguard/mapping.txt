android.support.v4.app.ActivityCompatHoneycomb -> android.support.v4.app.a:
    void invalidateOptionsMenu(android.app.Activity) -> a
android.support.v4.app.BackStackRecord -> android.support.v4.app.b:
    android.support.v4.app.FragmentManagerImpl mManager -> a
    android.support.v4.app.BackStackRecord$Op mHead -> b
    android.support.v4.app.BackStackRecord$Op mTail -> c
    int mNumOp -> d
    int mEnterAnim -> e
    int mExitAnim -> f
    int mPopEnterAnim -> g
    int mPopExitAnim -> h
    int mTransition -> i
    int mTransitionStyle -> j
    boolean mAddToBackStack -> k
    boolean mAllowAddToBackStack -> l
    java.lang.String mName -> m
    boolean mCommitted -> n
    int mIndex -> o
    int mBreadCrumbTitleRes -> p
    java.lang.CharSequence mBreadCrumbTitleText -> q
    int mBreadCrumbShortTitleRes -> r
    java.lang.CharSequence mBreadCrumbShortTitleText -> s
    java.lang.String toString() -> toString
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    void dump(java.lang.String,java.io.PrintWriter,boolean) -> a
    void addOp(android.support.v4.app.BackStackRecord$Op) -> a
    android.support.v4.app.FragmentTransaction add(int,android.support.v4.app.Fragment,java.lang.String) -> a
    void doAddOp(int,android.support.v4.app.Fragment,java.lang.String,int) -> a
    android.support.v4.app.FragmentTransaction detach(android.support.v4.app.Fragment) -> a
    android.support.v4.app.FragmentTransaction attach(android.support.v4.app.Fragment) -> b
    void bumpBackStackNesting(int) -> a
    int commit() -> a
    int commitInternal(boolean) -> a
    void run() -> run
    void popFromBackStack(boolean) -> b
    java.lang.String getName() -> b
android.support.v4.app.BackStackRecord$Op -> android.support.v4.app.c:
    android.support.v4.app.BackStackRecord$Op next -> a
    android.support.v4.app.BackStackRecord$Op prev -> b
    int cmd -> c
    android.support.v4.app.Fragment fragment -> d
    int enterAnim -> e
    int exitAnim -> f
    int popEnterAnim -> g
    int popExitAnim -> h
    java.util.ArrayList removed -> i
android.support.v4.app.BackStackState -> android.support.v4.app.BackStackState:
    int[] mOps -> a
    int mTransition -> b
    int mTransitionStyle -> c
    java.lang.String mName -> d
    int mIndex -> e
    int mBreadCrumbTitleRes -> f
    java.lang.CharSequence mBreadCrumbTitleText -> g
    int mBreadCrumbShortTitleRes -> h
    java.lang.CharSequence mBreadCrumbShortTitleText -> i
    android.os.Parcelable$Creator CREATOR -> CREATOR
    android.support.v4.app.BackStackRecord instantiate(android.support.v4.app.FragmentManagerImpl) -> a
    int describeContents() -> describeContents
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
android.support.v4.app.BackStackState$1 -> android.support.v4.app.d:
    android.support.v4.app.BackStackState createFromParcel(android.os.Parcel) -> a
    android.support.v4.app.BackStackState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.app.Fragment -> android.support.v4.app.Fragment:
    java.util.HashMap sClassMap -> P
    int mState -> a
    android.view.View mAnimatingAway -> b
    int mStateAfterAnimating -> c
    android.os.Bundle mSavedFragmentState -> d
    android.util.SparseArray mSavedViewState -> e
    int mIndex -> f
    java.lang.String mWho -> g
    android.os.Bundle mArguments -> h
    android.support.v4.app.Fragment mTarget -> i
    int mTargetIndex -> j
    int mTargetRequestCode -> k
    boolean mAdded -> l
    boolean mRemoving -> m
    boolean mResumed -> n
    boolean mFromLayout -> o
    boolean mInLayout -> p
    boolean mRestored -> q
    int mBackStackNesting -> r
    android.support.v4.app.FragmentManagerImpl mFragmentManager -> s
    android.support.v4.app.FragmentActivity mActivity -> t
    android.support.v4.app.FragmentManagerImpl mChildFragmentManager -> u
    android.support.v4.app.Fragment mParentFragment -> v
    int mFragmentId -> w
    int mContainerId -> x
    java.lang.String mTag -> y
    boolean mHidden -> z
    boolean mDetached -> A
    boolean mRetainInstance -> B
    boolean mRetaining -> C
    boolean mHasMenu -> D
    boolean mMenuVisible -> E
    boolean mCalled -> F
    int mNextAnim -> G
    android.view.ViewGroup mContainer -> H
    android.view.View mView -> I
    android.view.View mInnerView -> J
    boolean mDeferStart -> K
    boolean mUserVisibleHint -> L
    android.support.v4.app.LoaderManagerImpl mLoaderManager -> M
    boolean mLoadersStarted -> N
    boolean mCheckedForLoaderManager -> O
    android.support.v4.app.Fragment instantiate(android.content.Context,java.lang.String) -> a
    android.support.v4.app.Fragment instantiate(android.content.Context,java.lang.String,android.os.Bundle) -> a
    void restoreViewState(android.os.Bundle) -> a
    void setIndex(int,android.support.v4.app.Fragment) -> a
    boolean isInBackStack() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    android.support.v4.app.FragmentActivity getActivity() -> b
    android.content.res.Resources getResources() -> c
    boolean isDetached() -> d
    void onHiddenChanged(boolean) -> a
    void onActivityResult(int,int,android.content.Intent) -> a
    android.view.LayoutInflater getLayoutInflater(android.os.Bundle) -> b
    void onInflate(android.app.Activity,android.util.AttributeSet,android.os.Bundle) -> a
    void onAttach(android.app.Activity) -> a
    android.view.animation.Animation onCreateAnimation(int,boolean,int) -> a
    void onCreate(android.os.Bundle) -> c
    android.view.View onCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> a
    void onViewCreated(android.view.View,android.os.Bundle) -> a
    void onActivityCreated(android.os.Bundle) -> d
    void onViewStateRestored(android.os.Bundle) -> e
    void onStart() -> e
    void onResume() -> f
    void onSaveInstanceState(android.os.Bundle) -> f
    void onConfigurationChanged(android.content.res.Configuration) -> onConfigurationChanged
    void onPause() -> g
    void onStop() -> h
    void onLowMemory() -> onLowMemory
    void onDestroyView() -> i
    void onDestroy() -> j
    void initState() -> k
    void onDetach() -> l
    void onCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> a
    void onPrepareOptionsMenu(android.view.Menu) -> a
    void onDestroyOptionsMenu() -> m
    boolean onOptionsItemSelected(android.view.MenuItem) -> a
    void onOptionsMenuClosed(android.view.Menu) -> b
    void onCreateContextMenu(android.view.ContextMenu,android.view.View,android.view.ContextMenu$ContextMenuInfo) -> onCreateContextMenu
    boolean onContextItemSelected(android.view.MenuItem) -> b
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    void instantiateChildFragmentManager() -> n
    void performCreate(android.os.Bundle) -> g
    android.view.View performCreateView(android.view.LayoutInflater,android.view.ViewGroup,android.os.Bundle) -> b
    void performActivityCreated(android.os.Bundle) -> h
    void performStart() -> o
    void performResume() -> p
    void performConfigurationChanged(android.content.res.Configuration) -> a
    void performLowMemory() -> q
    boolean performCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> b
    boolean performPrepareOptionsMenu(android.view.Menu) -> c
    boolean performOptionsItemSelected(android.view.MenuItem) -> c
    boolean performContextItemSelected(android.view.MenuItem) -> d
    void performOptionsMenuClosed(android.view.Menu) -> d
    void performSaveInstanceState(android.os.Bundle) -> i
    void performPause() -> r
    void performStop() -> s
    void performReallyStop() -> t
    void performDestroyView() -> u
    void performDestroy() -> v
android.support.v4.app.Fragment$1 -> android.support.v4.app.e:
    android.support.v4.app.Fragment this$0 -> a
    android.view.View findViewById(int) -> a
android.support.v4.app.Fragment$InstantiationException -> android.support.v4.app.f:
android.support.v4.app.Fragment$SavedState -> android.support.v4.app.Fragment$SavedState:
    android.os.Bundle mState -> a
    android.os.Parcelable$Creator CREATOR -> CREATOR
    int describeContents() -> describeContents
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
android.support.v4.app.Fragment$SavedState$1 -> android.support.v4.app.g:
    android.support.v4.app.Fragment$SavedState createFromParcel(android.os.Parcel) -> a
    android.support.v4.app.Fragment$SavedState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.app.FragmentActivity -> android.support.v4.app.h:
    android.os.Handler mHandler -> a
    android.support.v4.app.FragmentManagerImpl mFragments -> b
    android.support.v4.app.FragmentContainer mContainer -> c
    boolean mCreated -> d
    boolean mResumed -> e
    boolean mStopped -> f
    boolean mReallyStopped -> g
    boolean mRetaining -> h
    boolean mOptionsMenuInvalidated -> i
    boolean mCheckedForLoaderManager -> j
    boolean mLoadersStarted -> k
    java.util.HashMap mAllLoaderManagers -> l
    android.support.v4.app.LoaderManagerImpl mLoaderManager -> m
    void onActivityResult(int,int,android.content.Intent) -> onActivityResult
    void onBackPressed() -> onBackPressed
    void onConfigurationChanged(android.content.res.Configuration) -> onConfigurationChanged
    void onCreate(android.os.Bundle) -> onCreate
    boolean onCreatePanelMenu(int,android.view.Menu) -> onCreatePanelMenu
    android.view.View onCreateView(java.lang.String,android.content.Context,android.util.AttributeSet) -> onCreateView
    void onDestroy() -> onDestroy
    boolean onKeyDown(int,android.view.KeyEvent) -> onKeyDown
    void onLowMemory() -> onLowMemory
    boolean onMenuItemSelected(int,android.view.MenuItem) -> onMenuItemSelected
    void onPanelClosed(int,android.view.Menu) -> onPanelClosed
    void onPause() -> onPause
    void onNewIntent(android.content.Intent) -> onNewIntent
    void onResume() -> onResume
    void onPostResume() -> onPostResume
    void onResumeFragments() -> a
    boolean onPreparePanel(int,android.view.View,android.view.Menu) -> onPreparePanel
    java.lang.Object onRetainNonConfigurationInstance() -> onRetainNonConfigurationInstance
    void onSaveInstanceState(android.os.Bundle) -> onSaveInstanceState
    void onStart() -> onStart
    void onStop() -> onStop
    java.lang.Object onRetainCustomNonConfigurationInstance() -> b
    void supportInvalidateOptionsMenu() -> c
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> dump
    java.lang.String viewToString(android.view.View) -> a
    void dumpViewHierarchy(java.lang.String,java.io.PrintWriter,android.view.View) -> a
    void doReallyStop(boolean) -> a
    void onReallyStop() -> d
    void onAttachFragment(android.support.v4.app.Fragment) -> a
    void startActivityForResult(android.content.Intent,int) -> startActivityForResult
    void invalidateSupportFragment(java.lang.String) -> a
    android.support.v4.app.LoaderManagerImpl getLoaderManager(java.lang.String,boolean,boolean) -> a
android.support.v4.app.FragmentActivity$FragmentTag -> android.support.v4.app.i:
    int[] Fragment -> a
android.support.v4.app.FragmentActivity$NonConfigurationInstances -> android.support.v4.app.j:
    java.lang.Object activity -> a
    java.lang.Object custom -> b
    java.util.HashMap children -> c
    java.util.ArrayList fragments -> d
    java.util.HashMap loaders -> e
android.support.v4.app.FragmentContainer -> android.support.v4.app.k:
    android.view.View findViewById(int) -> a
android.support.v4.app.FragmentManager -> android.support.v4.app.l:
    android.support.v4.app.FragmentTransaction beginTransaction() -> a
    boolean executePendingTransactions() -> b
    android.support.v4.app.Fragment findFragmentByTag(java.lang.String) -> a
android.support.v4.app.FragmentManager$OnBackStackChangedListener -> android.support.v4.app.m:
    void onBackStackChanged() -> a
android.support.v4.app.FragmentManagerImpl -> android.support.v4.app.n:
    boolean DEBUG -> a
    boolean HONEYCOMB -> b
    java.util.ArrayList mPendingActions -> c
    java.lang.Runnable[] mTmpActions -> d
    boolean mExecutingActions -> e
    java.util.ArrayList mActive -> f
    java.util.ArrayList mAdded -> g
    java.util.ArrayList mAvailIndices -> h
    java.util.ArrayList mBackStack -> i
    java.util.ArrayList mCreatedMenus -> j
    java.util.ArrayList mBackStackIndices -> k
    java.util.ArrayList mAvailBackStackIndices -> l
    java.util.ArrayList mBackStackChangeListeners -> m
    int mCurState -> n
    android.support.v4.app.FragmentActivity mActivity -> o
    android.support.v4.app.FragmentContainer mContainer -> p
    android.support.v4.app.Fragment mParent -> q
    boolean mNeedMenuInvalidate -> r
    boolean mStateSaved -> s
    boolean mDestroyed -> t
    java.lang.String mNoTransactionsBecause -> u
    boolean mHavePendingDeferredStart -> v
    android.os.Bundle mStateBundle -> w
    android.util.SparseArray mStateArray -> x
    java.lang.Runnable mExecCommit -> y
    android.view.animation.Interpolator DECELERATE_QUINT -> z
    android.view.animation.Interpolator DECELERATE_CUBIC -> A
    android.view.animation.Interpolator ACCELERATE_QUINT -> B
    android.view.animation.Interpolator ACCELERATE_CUBIC -> C
    void throwException(java.lang.RuntimeException) -> a
    android.support.v4.app.FragmentTransaction beginTransaction() -> a
    boolean executePendingTransactions() -> b
    boolean popBackStackImmediate() -> c
    void putFragment(android.os.Bundle,java.lang.String,android.support.v4.app.Fragment) -> a
    android.support.v4.app.Fragment getFragment(android.os.Bundle,java.lang.String) -> a
    java.lang.String toString() -> toString
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    android.view.animation.Animation makeOpenCloseAnimation(android.content.Context,float,float,float,float) -> a
    android.view.animation.Animation makeFadeAnimation(android.content.Context,float,float) -> a
    android.view.animation.Animation loadAnimation(android.support.v4.app.Fragment,int,boolean,int) -> a
    void performPendingDeferredStart(android.support.v4.app.Fragment) -> a
    void moveToState(android.support.v4.app.Fragment,int,int,int,boolean) -> a
    void moveToState(android.support.v4.app.Fragment) -> b
    void moveToState(int,boolean) -> a
    void moveToState(int,int,int,boolean) -> a
    void startPendingDeferredFragments() -> d
    void makeActive(android.support.v4.app.Fragment) -> c
    void makeInactive(android.support.v4.app.Fragment) -> d
    void addFragment(android.support.v4.app.Fragment,boolean) -> a
    void removeFragment(android.support.v4.app.Fragment,int,int) -> a
    void hideFragment(android.support.v4.app.Fragment,int,int) -> b
    void showFragment(android.support.v4.app.Fragment,int,int) -> c
    void detachFragment(android.support.v4.app.Fragment,int,int) -> d
    void attachFragment(android.support.v4.app.Fragment,int,int) -> e
    android.support.v4.app.Fragment findFragmentById(int) -> a
    android.support.v4.app.Fragment findFragmentByTag(java.lang.String) -> a
    void checkStateLoss() -> t
    void enqueueAction(java.lang.Runnable,boolean) -> a
    int allocBackStackIndex(android.support.v4.app.BackStackRecord) -> a
    void setBackStackIndex(int,android.support.v4.app.BackStackRecord) -> a
    void freeBackStackIndex(int) -> b
    boolean execPendingActions() -> e
    void reportBackStackChanged() -> f
    void addBackStackState(android.support.v4.app.BackStackRecord) -> b
    boolean popBackStackState(android.os.Handler,java.lang.String,int,int) -> a
    java.util.ArrayList retainNonConfig() -> g
    void saveFragmentViewState(android.support.v4.app.Fragment) -> e
    android.os.Bundle saveFragmentBasicState(android.support.v4.app.Fragment) -> f
    android.os.Parcelable saveAllState() -> h
    void restoreAllState(android.os.Parcelable,java.util.ArrayList) -> a
    void attachActivity(android.support.v4.app.FragmentActivity,android.support.v4.app.FragmentContainer,android.support.v4.app.Fragment) -> a
    void noteStateNotSaved() -> i
    void dispatchCreate() -> j
    void dispatchActivityCreated() -> k
    void dispatchStart() -> l
    void dispatchResume() -> m
    void dispatchPause() -> n
    void dispatchStop() -> o
    void dispatchReallyStop() -> p
    void dispatchDestroyView() -> q
    void dispatchDestroy() -> r
    void dispatchConfigurationChanged(android.content.res.Configuration) -> a
    void dispatchLowMemory() -> s
    boolean dispatchCreateOptionsMenu(android.view.Menu,android.view.MenuInflater) -> a
    boolean dispatchPrepareOptionsMenu(android.view.Menu) -> a
    boolean dispatchOptionsItemSelected(android.view.MenuItem) -> a
    boolean dispatchContextItemSelected(android.view.MenuItem) -> b
    void dispatchOptionsMenuClosed(android.view.Menu) -> b
    int reverseTransit(int) -> c
    int transitToStyleIndex(int,boolean) -> b
android.support.v4.app.FragmentManagerImpl$1 -> android.support.v4.app.o:
    android.support.v4.app.FragmentManagerImpl this$0 -> a
    void run() -> run
android.support.v4.app.FragmentManagerImpl$5 -> android.support.v4.app.p:
    android.support.v4.app.Fragment val$fragment -> a
    android.support.v4.app.FragmentManagerImpl this$0 -> b
    void onAnimationEnd(android.view.animation.Animation) -> onAnimationEnd
    void onAnimationRepeat(android.view.animation.Animation) -> onAnimationRepeat
    void onAnimationStart(android.view.animation.Animation) -> onAnimationStart
android.support.v4.app.FragmentManagerState -> android.support.v4.app.FragmentManagerState:
    android.support.v4.app.FragmentState[] mActive -> a
    int[] mAdded -> b
    android.support.v4.app.BackStackState[] mBackStack -> c
    android.os.Parcelable$Creator CREATOR -> CREATOR
    int describeContents() -> describeContents
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
android.support.v4.app.FragmentManagerState$1 -> android.support.v4.app.q:
    android.support.v4.app.FragmentManagerState createFromParcel(android.os.Parcel) -> a
    android.support.v4.app.FragmentManagerState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.app.FragmentState -> android.support.v4.app.FragmentState:
    java.lang.String mClassName -> a
    int mIndex -> b
    boolean mFromLayout -> c
    int mFragmentId -> d
    int mContainerId -> e
    java.lang.String mTag -> f
    boolean mRetainInstance -> g
    boolean mDetached -> h
    android.os.Bundle mArguments -> i
    android.os.Bundle mSavedFragmentState -> j
    android.support.v4.app.Fragment mInstance -> k
    android.os.Parcelable$Creator CREATOR -> CREATOR
    android.support.v4.app.Fragment instantiate(android.support.v4.app.FragmentActivity,android.support.v4.app.Fragment) -> a
    int describeContents() -> describeContents
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
android.support.v4.app.FragmentState$1 -> android.support.v4.app.r:
    android.support.v4.app.FragmentState createFromParcel(android.os.Parcel) -> a
    android.support.v4.app.FragmentState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.app.FragmentTabHost -> android.support.v4.app.FragmentTabHost:
    java.util.ArrayList mTabs -> a
    android.content.Context mContext -> b
    android.support.v4.app.FragmentManager mFragmentManager -> c
    int mContainerId -> d
    android.widget.TabHost$OnTabChangeListener mOnTabChangeListener -> e
    android.support.v4.app.FragmentTabHost$TabInfo mLastTab -> f
    boolean mAttached -> g
    void setup() -> setup
    void setOnTabChangedListener(android.widget.TabHost$OnTabChangeListener) -> setOnTabChangedListener
    void onAttachedToWindow() -> onAttachedToWindow
    void onDetachedFromWindow() -> onDetachedFromWindow
    android.os.Parcelable onSaveInstanceState() -> onSaveInstanceState
    void onRestoreInstanceState(android.os.Parcelable) -> onRestoreInstanceState
    void onTabChanged(java.lang.String) -> onTabChanged
    android.support.v4.app.FragmentTransaction doTabChanged(java.lang.String,android.support.v4.app.FragmentTransaction) -> a
android.support.v4.app.FragmentTabHost$1 -> android.support.v4.app.s:
android.support.v4.app.FragmentTabHost$SavedState -> android.support.v4.app.FragmentTabHost$SavedState:
    java.lang.String curTab -> a
    android.os.Parcelable$Creator CREATOR -> CREATOR
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
    java.lang.String toString() -> toString
android.support.v4.app.FragmentTabHost$SavedState$1 -> android.support.v4.app.t:
    android.support.v4.app.FragmentTabHost$SavedState createFromParcel(android.os.Parcel) -> a
    android.support.v4.app.FragmentTabHost$SavedState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.app.FragmentTabHost$TabInfo -> android.support.v4.app.u:
    java.lang.String tag -> a
    java.lang.Class clss -> b
    android.os.Bundle args -> c
    android.support.v4.app.Fragment fragment -> d
    android.support.v4.app.Fragment access$102(android.support.v4.app.FragmentTabHost$TabInfo,android.support.v4.app.Fragment) -> a
    android.support.v4.app.Fragment access$100(android.support.v4.app.FragmentTabHost$TabInfo) -> a
    java.lang.String access$200(android.support.v4.app.FragmentTabHost$TabInfo) -> b
    java.lang.Class access$300(android.support.v4.app.FragmentTabHost$TabInfo) -> c
    android.os.Bundle access$400(android.support.v4.app.FragmentTabHost$TabInfo) -> d
android.support.v4.app.FragmentTransaction -> android.support.v4.app.v:
    android.support.v4.app.FragmentTransaction add(int,android.support.v4.app.Fragment,java.lang.String) -> a
    android.support.v4.app.FragmentTransaction detach(android.support.v4.app.Fragment) -> a
    android.support.v4.app.FragmentTransaction attach(android.support.v4.app.Fragment) -> b
    int commit() -> a
android.support.v4.app.LoaderManager -> android.support.v4.app.w:
    boolean hasRunningLoaders() -> a
android.support.v4.app.LoaderManager$LoaderCallbacks -> android.support.v4.app.x:
    android.support.v4.content.Loader onCreateLoader(int,android.os.Bundle) -> a
    void onLoadFinished(android.support.v4.content.Loader,java.lang.Object) -> a
    void onLoaderReset(android.support.v4.content.Loader) -> a
android.support.v4.app.LoaderManagerImpl -> android.support.v4.app.y:
    boolean DEBUG -> a
    android.support.v4.util.SparseArrayCompat mLoaders -> b
    android.support.v4.util.SparseArrayCompat mInactiveLoaders -> c
    java.lang.String mWho -> d
    android.support.v4.app.FragmentActivity mActivity -> e
    boolean mStarted -> f
    boolean mRetaining -> g
    void updateActivity(android.support.v4.app.FragmentActivity) -> a
    void doStart() -> b
    void doStop() -> c
    void doRetain() -> d
    void finishRetain() -> e
    void doReportNextStart() -> f
    void doReportStart() -> g
    void doDestroy() -> h
    java.lang.String toString() -> toString
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
    boolean hasRunningLoaders() -> a
android.support.v4.app.LoaderManagerImpl$LoaderInfo -> android.support.v4.app.z:
    int mId -> a
    android.os.Bundle mArgs -> b
    android.support.v4.app.LoaderManager$LoaderCallbacks mCallbacks -> c
    android.support.v4.content.Loader mLoader -> d
    boolean mHaveData -> e
    boolean mDeliveredData -> f
    java.lang.Object mData -> g
    boolean mStarted -> h
    boolean mRetaining -> i
    boolean mRetainingStarted -> j
    boolean mReportNextStart -> k
    boolean mDestroyed -> l
    boolean mListenerRegistered -> m
    android.support.v4.app.LoaderManagerImpl$LoaderInfo mPendingLoader -> n
    android.support.v4.app.LoaderManagerImpl this$0 -> o
    void start() -> a
    void retain() -> b
    void finishRetain() -> c
    void reportStart() -> d
    void stop() -> e
    void destroy() -> f
    void callOnLoadFinished(android.support.v4.content.Loader,java.lang.Object) -> a
    java.lang.String toString() -> toString
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
android.support.v4.app.NoSaveStateFrameLayout -> android.support.v4.app.aa:
    android.view.ViewGroup wrap(android.view.View) -> a
    void dispatchSaveInstanceState(android.util.SparseArray) -> dispatchSaveInstanceState
    void dispatchRestoreInstanceState(android.util.SparseArray) -> dispatchRestoreInstanceState
android.support.v4.app.NotificationCompat -> android.support.v4.app.ab:
    android.support.v4.app.NotificationCompat$NotificationCompatImpl IMPL -> a
    android.support.v4.app.NotificationCompat$NotificationCompatImpl access$000() -> a
android.support.v4.app.NotificationCompat$Action -> android.support.v4.app.ac:
    int icon -> a
    java.lang.CharSequence title -> b
    android.app.PendingIntent actionIntent -> c
android.support.v4.app.NotificationCompat$BigPictureStyle -> android.support.v4.app.ad:
    android.graphics.Bitmap mPicture -> a
    android.graphics.Bitmap mBigLargeIcon -> b
    boolean mBigLargeIconSet -> c
android.support.v4.app.NotificationCompat$BigTextStyle -> android.support.v4.app.ae:
    java.lang.CharSequence mBigText -> a
android.support.v4.app.NotificationCompat$Builder -> android.support.v4.app.af:
    android.content.Context mContext -> a
    java.lang.CharSequence mContentTitle -> b
    java.lang.CharSequence mContentText -> c
    android.app.PendingIntent mContentIntent -> d
    android.app.PendingIntent mFullScreenIntent -> e
    android.widget.RemoteViews mTickerView -> f
    android.graphics.Bitmap mLargeIcon -> g
    java.lang.CharSequence mContentInfo -> h
    int mNumber -> i
    int mPriority -> j
    boolean mUseChronometer -> k
    android.support.v4.app.NotificationCompat$Style mStyle -> l
    java.lang.CharSequence mSubText -> m
    int mProgressMax -> n
    int mProgress -> o
    boolean mProgressIndeterminate -> p
    java.util.ArrayList mActions -> q
    android.app.Notification mNotification -> r
    android.support.v4.app.NotificationCompat$Builder setWhen(long) -> a
    android.support.v4.app.NotificationCompat$Builder setSmallIcon(int) -> a
    android.support.v4.app.NotificationCompat$Builder setContentTitle(java.lang.CharSequence) -> a
    android.support.v4.app.NotificationCompat$Builder setContentText(java.lang.CharSequence) -> b
    android.support.v4.app.NotificationCompat$Builder setContentIntent(android.app.PendingIntent) -> a
    android.support.v4.app.NotificationCompat$Builder setTicker(java.lang.CharSequence) -> c
    android.support.v4.app.NotificationCompat$Builder setAutoCancel(boolean) -> a
    void setFlag(int,boolean) -> a
    android.app.Notification getNotification() -> a
android.support.v4.app.NotificationCompat$InboxStyle -> android.support.v4.app.ag:
    java.util.ArrayList mTexts -> a
android.support.v4.app.NotificationCompat$NotificationCompatImpl -> android.support.v4.app.ah:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder) -> a
android.support.v4.app.NotificationCompat$NotificationCompatImplBase -> android.support.v4.app.ai:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder) -> a
android.support.v4.app.NotificationCompat$NotificationCompatImplHoneycomb -> android.support.v4.app.aj:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder) -> a
android.support.v4.app.NotificationCompat$NotificationCompatImplIceCreamSandwich -> android.support.v4.app.ak:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder) -> a
android.support.v4.app.NotificationCompat$NotificationCompatImplJellybean -> android.support.v4.app.al:
    android.app.Notification build(android.support.v4.app.NotificationCompat$Builder) -> a
android.support.v4.app.NotificationCompat$Style -> android.support.v4.app.am:
    java.lang.CharSequence mBigContentTitle -> d
    java.lang.CharSequence mSummaryText -> e
    boolean mSummaryTextSet -> f
android.support.v4.app.NotificationCompatHoneycomb -> android.support.v4.app.an:
    android.app.Notification add(android.content.Context,android.app.Notification,java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence,android.widget.RemoteViews,int,android.app.PendingIntent,android.app.PendingIntent,android.graphics.Bitmap) -> a
android.support.v4.app.NotificationCompatIceCreamSandwich -> android.support.v4.app.ao:
    android.app.Notification add(android.content.Context,android.app.Notification,java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence,android.widget.RemoteViews,int,android.app.PendingIntent,android.app.PendingIntent,android.graphics.Bitmap,int,int,boolean) -> a
android.support.v4.app.NotificationCompatJellybean -> android.support.v4.app.ap:
    android.app.Notification$Builder b -> a
    void addAction(int,java.lang.CharSequence,android.app.PendingIntent) -> a
    void addBigTextStyle(java.lang.CharSequence,boolean,java.lang.CharSequence,java.lang.CharSequence) -> a
    void addBigPictureStyle(java.lang.CharSequence,boolean,java.lang.CharSequence,android.graphics.Bitmap,android.graphics.Bitmap,boolean) -> a
    void addInboxStyle(java.lang.CharSequence,boolean,java.lang.CharSequence,java.util.ArrayList) -> a
    android.app.Notification build() -> a
android.support.v4.app.SuperNotCalledException -> android.support.v4.app.aq:
android.support.v4.content.Loader -> android.support.v4.a.a:
    int mId -> a
    android.support.v4.content.Loader$OnLoadCompleteListener mListener -> b
    boolean mStarted -> c
    boolean mAbandoned -> d
    boolean mReset -> e
    boolean mContentChanged -> f
    void registerListener(int,android.support.v4.content.Loader$OnLoadCompleteListener) -> a
    void unregisterListener(android.support.v4.content.Loader$OnLoadCompleteListener) -> a
    void startLoading() -> a
    void onStartLoading() -> b
    void stopLoading() -> c
    void onStopLoading() -> d
    void reset() -> e
    void onReset() -> f
    java.lang.String dataToString(java.lang.Object) -> a
    java.lang.String toString() -> toString
    void dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[]) -> a
android.support.v4.content.Loader$OnLoadCompleteListener -> android.support.v4.a.b:
android.support.v4.os.ParcelableCompat -> android.support.v4.b.a:
    android.os.Parcelable$Creator newCreator(android.support.v4.os.ParcelableCompatCreatorCallbacks) -> a
android.support.v4.os.ParcelableCompat$CompatCreator -> android.support.v4.b.b:
    android.support.v4.os.ParcelableCompatCreatorCallbacks mCallbacks -> a
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
    java.lang.Object[] newArray(int) -> newArray
android.support.v4.os.ParcelableCompatCreatorCallbacks -> android.support.v4.b.c:
    java.lang.Object createFromParcel(android.os.Parcel,java.lang.ClassLoader) -> a
    java.lang.Object[] newArray(int) -> a
android.support.v4.os.ParcelableCompatCreatorHoneycombMR2 -> android.support.v4.b.d:
    android.support.v4.os.ParcelableCompatCreatorCallbacks mCallbacks -> a
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
    java.lang.Object createFromParcel(android.os.Parcel,java.lang.ClassLoader) -> createFromParcel
    java.lang.Object[] newArray(int) -> newArray
android.support.v4.os.ParcelableCompatCreatorHoneycombMR2Stub -> android.support.v4.b.e:
    android.os.Parcelable$Creator instantiate(android.support.v4.os.ParcelableCompatCreatorCallbacks) -> a
android.support.v4.util.DebugUtils -> android.support.v4.c.a:
    void buildShortClassTag(java.lang.Object,java.lang.StringBuilder) -> a
android.support.v4.util.LogWriter -> android.support.v4.c.b:
    java.lang.String mTag -> a
    java.lang.StringBuilder mBuilder -> b
    void close() -> close
    void flush() -> flush
    void write(char[],int,int) -> write
    void flushBuilder() -> a
android.support.v4.util.SparseArrayCompat -> android.support.v4.c.c:
    java.lang.Object DELETED -> a
    boolean mGarbage -> b
    int[] mKeys -> c
    java.lang.Object[] mValues -> d
    int mSize -> e
    void gc() -> c
    int size() -> a
    int keyAt(int) -> a
    java.lang.Object valueAt(int) -> b
    void clear() -> b
    int idealByteArraySize(int) -> c
    int idealIntArraySize(int) -> d
android.support.v4.view.AccessibilityDelegateCompat -> android.support.v4.view.a:
    android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateImpl IMPL -> b
    java.lang.Object DEFAULT_DELEGATE -> c
    java.lang.Object mBridge -> a
    java.lang.Object getBridge() -> a
    void sendAccessibilityEvent(android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> d
    void onInitializeAccessibilityNodeInfo(android.view.View,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat getAccessibilityNodeProvider(android.view.View) -> a
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> a
android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateIcsImpl -> android.support.v4.view.b:
    java.lang.Object newAccessiblityDelegateDefaultImpl() -> a
    java.lang.Object newAccessiblityDelegateBridge(android.support.v4.view.AccessibilityDelegateCompat) -> a
    boolean dispatchPopulateAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(java.lang.Object,android.view.View,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    void onPopulateAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    boolean onRequestSendAccessibilityEvent(java.lang.Object,android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void sendAccessibilityEvent(java.lang.Object,android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> d
android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateIcsImpl$1 -> android.support.v4.view.c:
    android.support.v4.view.AccessibilityDelegateCompat val$compat -> a
    android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateIcsImpl this$0 -> b
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(android.view.View,java.lang.Object) -> a
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void sendAccessibilityEvent(android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(android.view.View,android.view.accessibility.AccessibilityEvent) -> d
android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateImpl -> android.support.v4.view.d:
    java.lang.Object newAccessiblityDelegateDefaultImpl() -> a
    java.lang.Object newAccessiblityDelegateBridge(android.support.v4.view.AccessibilityDelegateCompat) -> a
    boolean dispatchPopulateAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(java.lang.Object,android.view.View,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    void onPopulateAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    boolean onRequestSendAccessibilityEvent(java.lang.Object,android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void sendAccessibilityEvent(java.lang.Object,android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> d
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat getAccessibilityNodeProvider(java.lang.Object,android.view.View) -> a
    boolean performAccessibilityAction(java.lang.Object,android.view.View,int,android.os.Bundle) -> a
android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateJellyBeanImpl -> android.support.v4.view.e:
    java.lang.Object newAccessiblityDelegateBridge(android.support.v4.view.AccessibilityDelegateCompat) -> a
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat getAccessibilityNodeProvider(java.lang.Object,android.view.View) -> a
    boolean performAccessibilityAction(java.lang.Object,android.view.View,int,android.os.Bundle) -> a
android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateJellyBeanImpl$1 -> android.support.v4.view.f:
    android.support.v4.view.AccessibilityDelegateCompat val$compat -> a
    android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateJellyBeanImpl this$0 -> b
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(android.view.View,java.lang.Object) -> a
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void sendAccessibilityEvent(android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(android.view.View,android.view.accessibility.AccessibilityEvent) -> d
    java.lang.Object getAccessibilityNodeProvider(android.view.View) -> a
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> a
android.support.v4.view.AccessibilityDelegateCompat$AccessibilityDelegateStubImpl -> android.support.v4.view.g:
    java.lang.Object newAccessiblityDelegateDefaultImpl() -> a
    java.lang.Object newAccessiblityDelegateBridge(android.support.v4.view.AccessibilityDelegateCompat) -> a
    boolean dispatchPopulateAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(java.lang.Object,android.view.View,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    void onPopulateAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    boolean onRequestSendAccessibilityEvent(java.lang.Object,android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void sendAccessibilityEvent(java.lang.Object,android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> d
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat getAccessibilityNodeProvider(java.lang.Object,android.view.View) -> a
    boolean performAccessibilityAction(java.lang.Object,android.view.View,int,android.os.Bundle) -> a
android.support.v4.view.AccessibilityDelegateCompatIcs -> android.support.v4.view.h:
    java.lang.Object newAccessibilityDelegateDefaultImpl() -> a
    java.lang.Object newAccessibilityDelegateBridge(android.support.v4.view.AccessibilityDelegateCompatIcs$AccessibilityDelegateBridge) -> a
    boolean dispatchPopulateAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(java.lang.Object,android.view.View,java.lang.Object) -> a
    void onPopulateAccessibilityEvent(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    boolean onRequestSendAccessibilityEvent(java.lang.Object,android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void sendAccessibilityEvent(java.lang.Object,android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(java.lang.Object,android.view.View,android.view.accessibility.AccessibilityEvent) -> d
android.support.v4.view.AccessibilityDelegateCompatIcs$1 -> android.support.v4.view.i:
    android.support.v4.view.AccessibilityDelegateCompatIcs$AccessibilityDelegateBridge val$bridge -> a
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> dispatchPopulateAccessibilityEvent
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> onInitializeAccessibilityEvent
    void onInitializeAccessibilityNodeInfo(android.view.View,android.view.accessibility.AccessibilityNodeInfo) -> onInitializeAccessibilityNodeInfo
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> onPopulateAccessibilityEvent
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> onRequestSendAccessibilityEvent
    void sendAccessibilityEvent(android.view.View,int) -> sendAccessibilityEvent
    void sendAccessibilityEventUnchecked(android.view.View,android.view.accessibility.AccessibilityEvent) -> sendAccessibilityEventUnchecked
android.support.v4.view.AccessibilityDelegateCompatIcs$AccessibilityDelegateBridge -> android.support.v4.view.j:
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(android.view.View,java.lang.Object) -> a
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void sendAccessibilityEvent(android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(android.view.View,android.view.accessibility.AccessibilityEvent) -> d
android.support.v4.view.AccessibilityDelegateCompatJellyBean -> android.support.v4.view.k:
    java.lang.Object newAccessibilityDelegateBridge(android.support.v4.view.AccessibilityDelegateCompatJellyBean$AccessibilityDelegateBridgeJellyBean) -> a
    java.lang.Object getAccessibilityNodeProvider(java.lang.Object,android.view.View) -> a
    boolean performAccessibilityAction(java.lang.Object,android.view.View,int,android.os.Bundle) -> a
android.support.v4.view.AccessibilityDelegateCompatJellyBean$1 -> android.support.v4.view.l:
    android.support.v4.view.AccessibilityDelegateCompatJellyBean$AccessibilityDelegateBridgeJellyBean val$bridge -> a
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> dispatchPopulateAccessibilityEvent
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> onInitializeAccessibilityEvent
    void onInitializeAccessibilityNodeInfo(android.view.View,android.view.accessibility.AccessibilityNodeInfo) -> onInitializeAccessibilityNodeInfo
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> onPopulateAccessibilityEvent
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> onRequestSendAccessibilityEvent
    void sendAccessibilityEvent(android.view.View,int) -> sendAccessibilityEvent
    void sendAccessibilityEventUnchecked(android.view.View,android.view.accessibility.AccessibilityEvent) -> sendAccessibilityEventUnchecked
    android.view.accessibility.AccessibilityNodeProvider getAccessibilityNodeProvider(android.view.View) -> getAccessibilityNodeProvider
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> performAccessibilityAction
android.support.v4.view.AccessibilityDelegateCompatJellyBean$AccessibilityDelegateBridgeJellyBean -> android.support.v4.view.m:
    boolean dispatchPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> b
    void onInitializeAccessibilityNodeInfo(android.view.View,java.lang.Object) -> a
    void onPopulateAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> c
    boolean onRequestSendAccessibilityEvent(android.view.ViewGroup,android.view.View,android.view.accessibility.AccessibilityEvent) -> a
    void sendAccessibilityEvent(android.view.View,int) -> a
    void sendAccessibilityEventUnchecked(android.view.View,android.view.accessibility.AccessibilityEvent) -> d
    java.lang.Object getAccessibilityNodeProvider(android.view.View) -> a
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> a
android.support.v4.view.GravityCompat -> android.support.v4.view.n:
    android.support.v4.view.GravityCompat$GravityCompatImpl IMPL -> a
    int getAbsoluteGravity(int,int) -> a
android.support.v4.view.GravityCompat$GravityCompatImpl -> android.support.v4.view.o:
    int getAbsoluteGravity(int,int) -> a
android.support.v4.view.GravityCompat$GravityCompatImplBase -> android.support.v4.view.p:
    int getAbsoluteGravity(int,int) -> a
android.support.v4.view.GravityCompat$GravityCompatImplJellybeanMr1 -> android.support.v4.view.q:
    int getAbsoluteGravity(int,int) -> a
android.support.v4.view.GravityCompatJellybeanMr1 -> android.support.v4.view.r:
    int getAbsoluteGravity(int,int) -> a
android.support.v4.view.KeyEventCompat -> android.support.v4.view.s:
    android.support.v4.view.KeyEventCompat$KeyEventVersionImpl IMPL -> a
    boolean hasModifiers(android.view.KeyEvent,int) -> a
    boolean hasNoModifiers(android.view.KeyEvent) -> a
    void startTracking(android.view.KeyEvent) -> b
android.support.v4.view.KeyEventCompat$BaseKeyEventVersionImpl -> android.support.v4.view.t:
    int metaStateFilterDirectionalModifiers(int,int,int,int,int) -> a
    int normalizeMetaState(int) -> a
    boolean metaStateHasModifiers(int,int) -> a
    boolean metaStateHasNoModifiers(int) -> b
    void startTracking(android.view.KeyEvent) -> a
android.support.v4.view.KeyEventCompat$EclairKeyEventVersionImpl -> android.support.v4.view.u:
    void startTracking(android.view.KeyEvent) -> a
android.support.v4.view.KeyEventCompat$HoneycombKeyEventVersionImpl -> android.support.v4.view.v:
    int normalizeMetaState(int) -> a
    boolean metaStateHasModifiers(int,int) -> a
    boolean metaStateHasNoModifiers(int) -> b
android.support.v4.view.KeyEventCompat$KeyEventVersionImpl -> android.support.v4.view.w:
    boolean metaStateHasModifiers(int,int) -> a
    boolean metaStateHasNoModifiers(int) -> b
    void startTracking(android.view.KeyEvent) -> a
android.support.v4.view.KeyEventCompatEclair -> android.support.v4.view.x:
    void startTracking(android.view.KeyEvent) -> a
android.support.v4.view.KeyEventCompatHoneycomb -> android.support.v4.view.y:
    int normalizeMetaState(int) -> a
    boolean metaStateHasModifiers(int,int) -> a
    boolean metaStateHasNoModifiers(int) -> b
android.support.v4.view.MotionEventCompat -> android.support.v4.view.z:
    android.support.v4.view.MotionEventCompat$MotionEventVersionImpl IMPL -> a
    int getActionMasked(android.view.MotionEvent) -> a
    int getActionIndex(android.view.MotionEvent) -> b
    int findPointerIndex(android.view.MotionEvent,int) -> a
    int getPointerId(android.view.MotionEvent,int) -> b
    float getX(android.view.MotionEvent,int) -> c
    float getY(android.view.MotionEvent,int) -> d
    int getPointerCount(android.view.MotionEvent) -> c
android.support.v4.view.MotionEventCompat$BaseMotionEventVersionImpl -> android.support.v4.view.aa:
    int findPointerIndex(android.view.MotionEvent,int) -> a
    int getPointerId(android.view.MotionEvent,int) -> b
    float getX(android.view.MotionEvent,int) -> c
    float getY(android.view.MotionEvent,int) -> d
    int getPointerCount(android.view.MotionEvent) -> a
android.support.v4.view.MotionEventCompat$EclairMotionEventVersionImpl -> android.support.v4.view.ab:
    int findPointerIndex(android.view.MotionEvent,int) -> a
    int getPointerId(android.view.MotionEvent,int) -> b
    float getX(android.view.MotionEvent,int) -> c
    float getY(android.view.MotionEvent,int) -> d
    int getPointerCount(android.view.MotionEvent) -> a
android.support.v4.view.MotionEventCompat$MotionEventVersionImpl -> android.support.v4.view.ac:
    int findPointerIndex(android.view.MotionEvent,int) -> a
    int getPointerId(android.view.MotionEvent,int) -> b
    float getX(android.view.MotionEvent,int) -> c
    float getY(android.view.MotionEvent,int) -> d
    int getPointerCount(android.view.MotionEvent) -> a
android.support.v4.view.MotionEventCompatEclair -> android.support.v4.view.ad:
    int findPointerIndex(android.view.MotionEvent,int) -> a
    int getPointerId(android.view.MotionEvent,int) -> b
    float getX(android.view.MotionEvent,int) -> c
    float getY(android.view.MotionEvent,int) -> d
    int getPointerCount(android.view.MotionEvent) -> a
android.support.v4.view.PagerAdapter -> android.support.v4.view.ae:
    android.database.DataSetObservable mObservable -> a
    int getCount() -> a
    void startUpdate(android.view.ViewGroup) -> a
    java.lang.Object instantiateItem(android.view.ViewGroup,int) -> a
    void destroyItem(android.view.ViewGroup,int,java.lang.Object) -> a
    void setPrimaryItem(android.view.ViewGroup,int,java.lang.Object) -> b
    void finishUpdate(android.view.ViewGroup) -> b
    void startUpdate(android.view.View) -> a
    java.lang.Object instantiateItem(android.view.View,int) -> a
    void destroyItem(android.view.View,int,java.lang.Object) -> a
    void setPrimaryItem(android.view.View,int,java.lang.Object) -> b
    void finishUpdate(android.view.View) -> b
    boolean isViewFromObject(android.view.View,java.lang.Object) -> a
    android.os.Parcelable saveState() -> b
    void restoreState(android.os.Parcelable,java.lang.ClassLoader) -> a
    int getItemPosition(java.lang.Object) -> a
    void registerDataSetObserver(android.database.DataSetObserver) -> a
    void unregisterDataSetObserver(android.database.DataSetObserver) -> b
    float getPageWidth(int) -> a
android.support.v4.view.VelocityTrackerCompat -> android.support.v4.view.af:
    android.support.v4.view.VelocityTrackerCompat$VelocityTrackerVersionImpl IMPL -> a
    float getXVelocity(android.view.VelocityTracker,int) -> a
    float getYVelocity(android.view.VelocityTracker,int) -> b
android.support.v4.view.VelocityTrackerCompat$BaseVelocityTrackerVersionImpl -> android.support.v4.view.ag:
    float getXVelocity(android.view.VelocityTracker,int) -> a
    float getYVelocity(android.view.VelocityTracker,int) -> b
android.support.v4.view.VelocityTrackerCompat$HoneycombVelocityTrackerVersionImpl -> android.support.v4.view.ah:
    float getXVelocity(android.view.VelocityTracker,int) -> a
    float getYVelocity(android.view.VelocityTracker,int) -> b
android.support.v4.view.VelocityTrackerCompat$VelocityTrackerVersionImpl -> android.support.v4.view.ai:
    float getXVelocity(android.view.VelocityTracker,int) -> a
    float getYVelocity(android.view.VelocityTracker,int) -> b
android.support.v4.view.VelocityTrackerCompatHoneycomb -> android.support.v4.view.aj:
    float getXVelocity(android.view.VelocityTracker,int) -> a
    float getYVelocity(android.view.VelocityTracker,int) -> b
android.support.v4.view.ViewCompat -> android.support.v4.view.ak:
    android.support.v4.view.ViewCompat$ViewCompatImpl IMPL -> a
    boolean canScrollHorizontally(android.view.View,int) -> a
    int getOverScrollMode(android.view.View) -> a
    void setAccessibilityDelegate(android.view.View,android.support.v4.view.AccessibilityDelegateCompat) -> a
    void postInvalidateOnAnimation(android.view.View) -> b
    void postInvalidateOnAnimation(android.view.View,int,int,int,int) -> a
    void postOnAnimation(android.view.View,java.lang.Runnable) -> a
    int getImportantForAccessibility(android.view.View) -> c
    void setImportantForAccessibility(android.view.View,int) -> b
    void setLayerType(android.view.View,int,android.graphics.Paint) -> a
    int getLayerType(android.view.View) -> d
    void setLayerPaint(android.view.View,android.graphics.Paint) -> a
    int getLayoutDirection(android.view.View) -> e
android.support.v4.view.ViewCompat$BaseViewCompatImpl -> android.support.v4.view.al:
    boolean canScrollHorizontally(android.view.View,int) -> a
    int getOverScrollMode(android.view.View) -> a
    void setAccessibilityDelegate(android.view.View,android.support.v4.view.AccessibilityDelegateCompat) -> a
    void postInvalidateOnAnimation(android.view.View) -> b
    void postInvalidateOnAnimation(android.view.View,int,int,int,int) -> a
    void postOnAnimation(android.view.View,java.lang.Runnable) -> a
    long getFrameTime() -> a
    int getImportantForAccessibility(android.view.View) -> c
    void setImportantForAccessibility(android.view.View,int) -> b
    void setLayerType(android.view.View,int,android.graphics.Paint) -> a
    int getLayerType(android.view.View) -> d
    void setLayerPaint(android.view.View,android.graphics.Paint) -> a
    int getLayoutDirection(android.view.View) -> e
android.support.v4.view.ViewCompat$GBViewCompatImpl -> android.support.v4.view.am:
    int getOverScrollMode(android.view.View) -> a
android.support.v4.view.ViewCompat$HCViewCompatImpl -> android.support.v4.view.an:
    long getFrameTime() -> a
    void setLayerType(android.view.View,int,android.graphics.Paint) -> a
    int getLayerType(android.view.View) -> d
    void setLayerPaint(android.view.View,android.graphics.Paint) -> a
android.support.v4.view.ViewCompat$ICSViewCompatImpl -> android.support.v4.view.ao:
    boolean canScrollHorizontally(android.view.View,int) -> a
    void setAccessibilityDelegate(android.view.View,android.support.v4.view.AccessibilityDelegateCompat) -> a
android.support.v4.view.ViewCompat$JBViewCompatImpl -> android.support.v4.view.ap:
    void postInvalidateOnAnimation(android.view.View) -> b
    void postInvalidateOnAnimation(android.view.View,int,int,int,int) -> a
    void postOnAnimation(android.view.View,java.lang.Runnable) -> a
    int getImportantForAccessibility(android.view.View) -> c
    void setImportantForAccessibility(android.view.View,int) -> b
android.support.v4.view.ViewCompat$JbMr1ViewCompatImpl -> android.support.v4.view.aq:
    void setLayerPaint(android.view.View,android.graphics.Paint) -> a
    int getLayoutDirection(android.view.View) -> e
android.support.v4.view.ViewCompat$ViewCompatImpl -> android.support.v4.view.ar:
    boolean canScrollHorizontally(android.view.View,int) -> a
    int getOverScrollMode(android.view.View) -> a
    void setAccessibilityDelegate(android.view.View,android.support.v4.view.AccessibilityDelegateCompat) -> a
    void postInvalidateOnAnimation(android.view.View) -> b
    void postInvalidateOnAnimation(android.view.View,int,int,int,int) -> a
    void postOnAnimation(android.view.View,java.lang.Runnable) -> a
    int getImportantForAccessibility(android.view.View) -> c
    void setImportantForAccessibility(android.view.View,int) -> b
    void setLayerType(android.view.View,int,android.graphics.Paint) -> a
    int getLayerType(android.view.View) -> d
    void setLayerPaint(android.view.View,android.graphics.Paint) -> a
    int getLayoutDirection(android.view.View) -> e
android.support.v4.view.ViewCompatGingerbread -> android.support.v4.view.as:
    int getOverScrollMode(android.view.View) -> a
android.support.v4.view.ViewCompatHC -> android.support.v4.view.at:
    long getFrameTime() -> a
    void setLayerType(android.view.View,int,android.graphics.Paint) -> a
    int getLayerType(android.view.View) -> a
android.support.v4.view.ViewCompatICS -> android.support.v4.view.au:
    boolean canScrollHorizontally(android.view.View,int) -> a
    void setAccessibilityDelegate(android.view.View,java.lang.Object) -> a
android.support.v4.view.ViewCompatJB -> android.support.v4.view.av:
    void postInvalidateOnAnimation(android.view.View) -> a
    void postInvalidateOnAnimation(android.view.View,int,int,int,int) -> a
    void postOnAnimation(android.view.View,java.lang.Runnable) -> a
    int getImportantForAccessibility(android.view.View) -> b
    void setImportantForAccessibility(android.view.View,int) -> a
android.support.v4.view.ViewCompatJellybeanMr1 -> android.support.v4.view.aw:
    void setLayerPaint(android.view.View,android.graphics.Paint) -> a
    int getLayoutDirection(android.view.View) -> a
android.support.v4.view.ViewConfigurationCompat -> android.support.v4.view.ax:
    android.support.v4.view.ViewConfigurationCompat$ViewConfigurationVersionImpl IMPL -> a
    int getScaledPagingTouchSlop(android.view.ViewConfiguration) -> a
android.support.v4.view.ViewConfigurationCompat$BaseViewConfigurationVersionImpl -> android.support.v4.view.ay:
    int getScaledPagingTouchSlop(android.view.ViewConfiguration) -> a
android.support.v4.view.ViewConfigurationCompat$FroyoViewConfigurationVersionImpl -> android.support.v4.view.az:
    int getScaledPagingTouchSlop(android.view.ViewConfiguration) -> a
android.support.v4.view.ViewConfigurationCompat$ViewConfigurationVersionImpl -> android.support.v4.view.ba:
    int getScaledPagingTouchSlop(android.view.ViewConfiguration) -> a
android.support.v4.view.ViewConfigurationCompatFroyo -> android.support.v4.view.bb:
    int getScaledPagingTouchSlop(android.view.ViewConfiguration) -> a
android.support.v4.view.ViewPager -> android.support.v4.view.ViewPager:
    int[] LAYOUT_ATTRS -> a
    int mExpectedAdapterCount -> b
    java.util.Comparator COMPARATOR -> c
    android.view.animation.Interpolator sInterpolator -> d
    java.util.ArrayList mItems -> e
    android.support.v4.view.ViewPager$ItemInfo mTempItem -> f
    android.graphics.Rect mTempRect -> g
    android.support.v4.view.PagerAdapter mAdapter -> h
    int mCurItem -> i
    int mRestoredCurItem -> j
    android.os.Parcelable mRestoredAdapterState -> k
    java.lang.ClassLoader mRestoredClassLoader -> l
    android.widget.Scroller mScroller -> m
    android.support.v4.view.ViewPager$PagerObserver mObserver -> n
    int mPageMargin -> o
    android.graphics.drawable.Drawable mMarginDrawable -> p
    int mTopPageBounds -> q
    int mBottomPageBounds -> r
    float mFirstOffset -> s
    float mLastOffset -> t
    int mChildWidthMeasureSpec -> u
    int mChildHeightMeasureSpec -> v
    boolean mInLayout -> w
    boolean mScrollingCacheEnabled -> x
    boolean mPopulatePending -> y
    int mOffscreenPageLimit -> z
    boolean mIsBeingDragged -> A
    boolean mIsUnableToDrag -> B
    int mDefaultGutterSize -> C
    int mGutterSize -> D
    int mTouchSlop -> E
    float mLastMotionX -> F
    float mLastMotionY -> G
    float mInitialMotionX -> H
    float mInitialMotionY -> I
    int mActivePointerId -> J
    android.view.VelocityTracker mVelocityTracker -> K
    int mMinimumVelocity -> L
    int mMaximumVelocity -> M
    int mFlingDistance -> N
    int mCloseEnough -> O
    boolean mFakeDragging -> P
    android.support.v4.widget.EdgeEffectCompat mLeftEdge -> Q
    android.support.v4.widget.EdgeEffectCompat mRightEdge -> R
    boolean mFirstLayout -> S
    boolean mNeedCalculatePageOffsets -> T
    boolean mCalledSuper -> U
    int mDecorChildCount -> V
    android.support.v4.view.ViewPager$OnPageChangeListener mOnPageChangeListener -> W
    android.support.v4.view.ViewPager$OnPageChangeListener mInternalPageChangeListener -> Z
    android.support.v4.view.ViewPager$OnAdapterChangeListener mAdapterChangeListener -> aa
    android.support.v4.view.ViewPager$PageTransformer mPageTransformer -> ab
    java.lang.reflect.Method mSetChildrenDrawingOrderEnabled -> ac
    int mDrawingOrder -> ad
    java.util.ArrayList mDrawingOrderedChildren -> ae
    android.support.v4.view.ViewPager$ViewPositionComparator sPositionComparator -> af
    java.lang.Runnable mEndScrollRunnable -> ag
    int mScrollState -> ah
    void initViewPager() -> a
    void onDetachedFromWindow() -> onDetachedFromWindow
    void setScrollState(int) -> setScrollState
    void setAdapter(android.support.v4.view.PagerAdapter) -> setAdapter
    void removeNonDecorViews() -> g
    android.support.v4.view.PagerAdapter getAdapter() -> getAdapter
    void setOnAdapterChangeListener(android.support.v4.view.ViewPager$OnAdapterChangeListener) -> setOnAdapterChangeListener
    int getClientWidth() -> getClientWidth
    void setCurrentItem(int) -> setCurrentItem
    void setCurrentItem(int,boolean) -> a
    int getCurrentItem() -> getCurrentItem
    void setCurrentItemInternal(int,boolean,boolean) -> a
    void setCurrentItemInternal(int,boolean,boolean,int) -> a
    void scrollToItem(int,boolean,int,boolean) -> a
    void setOnPageChangeListener(android.support.v4.view.ViewPager$OnPageChangeListener) -> setOnPageChangeListener
    void setChildrenDrawingOrderEnabledCompat(boolean) -> setChildrenDrawingOrderEnabledCompat
    int getChildDrawingOrder(int,int) -> getChildDrawingOrder
    int getOffscreenPageLimit() -> getOffscreenPageLimit
    void setOffscreenPageLimit(int) -> setOffscreenPageLimit
    void setPageMargin(int) -> setPageMargin
    int getPageMargin() -> getPageMargin
    void setPageMarginDrawable(android.graphics.drawable.Drawable) -> setPageMarginDrawable
    void setPageMarginDrawable(int) -> setPageMarginDrawable
    boolean verifyDrawable(android.graphics.drawable.Drawable) -> verifyDrawable
    void drawableStateChanged() -> drawableStateChanged
    float distanceInfluenceForSnapDuration(float) -> a
    void smoothScrollTo(int,int,int) -> a
    android.support.v4.view.ViewPager$ItemInfo addNewItem(int,int) -> a
    void dataSetChanged() -> b
    void populate() -> c
    void populate(int) -> a
    void sortChildDrawingOrder() -> h
    void calculatePageOffsets(android.support.v4.view.ViewPager$ItemInfo,int,android.support.v4.view.ViewPager$ItemInfo) -> a
    android.os.Parcelable onSaveInstanceState() -> onSaveInstanceState
    void onRestoreInstanceState(android.os.Parcelable) -> onRestoreInstanceState
    void addView(android.view.View,int,android.view.ViewGroup$LayoutParams) -> addView
    void removeView(android.view.View) -> removeView
    android.support.v4.view.ViewPager$ItemInfo infoForChild(android.view.View) -> a
    android.support.v4.view.ViewPager$ItemInfo infoForAnyChild(android.view.View) -> b
    android.support.v4.view.ViewPager$ItemInfo infoForPosition(int) -> b
    void onAttachedToWindow() -> onAttachedToWindow
    void onMeasure(int,int) -> onMeasure
    void onSizeChanged(int,int,int,int) -> onSizeChanged
    void recomputeScrollPosition(int,int,int,int) -> a
    void onLayout(boolean,int,int,int,int) -> onLayout
    void computeScroll() -> computeScroll
    boolean pageScrolled(int) -> d
    void onPageScrolled(int,float,int) -> a
    void completeScroll(boolean) -> a
    boolean isGutterDrag(float,float) -> a
    void enableLayers(boolean) -> b
    boolean onInterceptTouchEvent(android.view.MotionEvent) -> onInterceptTouchEvent
    boolean onTouchEvent(android.view.MotionEvent) -> onTouchEvent
    boolean performDrag(float) -> b
    android.support.v4.view.ViewPager$ItemInfo infoForCurrentScrollPosition() -> i
    int determineTargetPage(int,float,int,int) -> a
    void draw(android.graphics.Canvas) -> draw
    void onDraw(android.graphics.Canvas) -> onDraw
    void onSecondaryPointerUp(android.view.MotionEvent) -> a
    void endDrag() -> j
    void setScrollingCacheEnabled(boolean) -> setScrollingCacheEnabled
    boolean canScroll(android.view.View,boolean,int,int,int) -> a
    boolean dispatchKeyEvent(android.view.KeyEvent) -> dispatchKeyEvent
    boolean executeKeyEvent(android.view.KeyEvent) -> a
    boolean arrowScroll(int) -> c
    android.graphics.Rect getChildRectInPagerCoordinates(android.graphics.Rect,android.view.View) -> a
    boolean pageLeft() -> d
    boolean pageRight() -> e
    void addFocusables(java.util.ArrayList,int,int) -> addFocusables
    void addTouchables(java.util.ArrayList) -> addTouchables
    boolean onRequestFocusInDescendants(int,android.graphics.Rect) -> onRequestFocusInDescendants
    boolean dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent) -> dispatchPopulateAccessibilityEvent
    android.view.ViewGroup$LayoutParams generateDefaultLayoutParams() -> generateDefaultLayoutParams
    android.view.ViewGroup$LayoutParams generateLayoutParams(android.view.ViewGroup$LayoutParams) -> generateLayoutParams
    boolean checkLayoutParams(android.view.ViewGroup$LayoutParams) -> checkLayoutParams
    android.view.ViewGroup$LayoutParams generateLayoutParams(android.util.AttributeSet) -> generateLayoutParams
    void access$000(android.support.v4.view.ViewPager,int) -> a
    android.support.v4.view.PagerAdapter access$200(android.support.v4.view.ViewPager) -> a
    int access$300(android.support.v4.view.ViewPager) -> b
    int[] access$400() -> f
android.support.v4.view.ViewPager$1 -> android.support.v4.view.bc:
    int compare(android.support.v4.view.ViewPager$ItemInfo,android.support.v4.view.ViewPager$ItemInfo) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
android.support.v4.view.ViewPager$2 -> android.support.v4.view.bd:
    float getInterpolation(float) -> getInterpolation
android.support.v4.view.ViewPager$3 -> android.support.v4.view.be:
    android.support.v4.view.ViewPager this$0 -> a
    void run() -> run
android.support.v4.view.ViewPager$Decor -> android.support.v4.view.bf:
android.support.v4.view.ViewPager$ItemInfo -> android.support.v4.view.bg:
    java.lang.Object object -> a
    int position -> b
    boolean scrolling -> c
    float widthFactor -> d
    float offset -> e
android.support.v4.view.ViewPager$LayoutParams -> android.support.v4.view.bh:
    boolean isDecor -> a
    int gravity -> b
    float widthFactor -> c
    boolean needsMeasure -> d
    int position -> e
    int childIndex -> f
android.support.v4.view.ViewPager$MyAccessibilityDelegate -> android.support.v4.view.bi:
    android.support.v4.view.ViewPager this$0 -> b
    void onInitializeAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent) -> d
    void onInitializeAccessibilityNodeInfo(android.view.View,android.support.v4.view.accessibility.AccessibilityNodeInfoCompat) -> a
    boolean performAccessibilityAction(android.view.View,int,android.os.Bundle) -> a
android.support.v4.view.ViewPager$OnAdapterChangeListener -> android.support.v4.view.bj:
    void onAdapterChanged(android.support.v4.view.PagerAdapter,android.support.v4.view.PagerAdapter) -> a
android.support.v4.view.ViewPager$OnPageChangeListener -> android.support.v4.view.bk:
    void onPageScrolled(int,float,int) -> a
    void onPageSelected(int) -> a
    void onPageScrollStateChanged(int) -> b
android.support.v4.view.ViewPager$PageTransformer -> android.support.v4.view.bl:
    void transformPage(android.view.View,float) -> a
android.support.v4.view.ViewPager$PagerObserver -> android.support.v4.view.bm:
    android.support.v4.view.ViewPager this$0 -> a
    void onChanged() -> onChanged
    void onInvalidated() -> onInvalidated
android.support.v4.view.ViewPager$SavedState -> android.support.v4.view.ViewPager$SavedState:
    int position -> a
    android.os.Parcelable adapterState -> b
    java.lang.ClassLoader loader -> c
    android.os.Parcelable$Creator CREATOR -> CREATOR
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
    java.lang.String toString() -> toString
android.support.v4.view.ViewPager$SavedState$1 -> android.support.v4.view.bn:
    android.support.v4.view.ViewPager$SavedState createFromParcel(android.os.Parcel,java.lang.ClassLoader) -> b
    android.support.v4.view.ViewPager$SavedState[] newArray(int) -> b
    java.lang.Object[] newArray(int) -> a
    java.lang.Object createFromParcel(android.os.Parcel,java.lang.ClassLoader) -> a
android.support.v4.view.ViewPager$ViewPositionComparator -> android.support.v4.view.bo:
    int compare(android.view.View,android.view.View) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
android.support.v4.view.accessibility.AccessibilityNodeInfoCompat -> android.support.v4.view.a.a:
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityNodeInfoImpl IMPL -> a
    java.lang.Object mInfo -> b
    java.lang.Object getInfo() -> a
    void addAction(int) -> a
    void setScrollable(boolean) -> a
    void setClassName(java.lang.CharSequence) -> a
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
android.support.v4.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityNodeInfoIcsImpl -> android.support.v4.view.a.b:
    void addAction(java.lang.Object,int) -> a
    void setClassName(java.lang.Object,java.lang.CharSequence) -> a
    void setScrollable(java.lang.Object,boolean) -> a
android.support.v4.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityNodeInfoImpl -> android.support.v4.view.a.c:
    void addAction(java.lang.Object,int) -> a
    void setScrollable(java.lang.Object,boolean) -> a
    void setClassName(java.lang.Object,java.lang.CharSequence) -> a
android.support.v4.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityNodeInfoJellybeanImpl -> android.support.v4.view.a.d:
android.support.v4.view.accessibility.AccessibilityNodeInfoCompat$AccessibilityNodeInfoStubImpl -> android.support.v4.view.a.e:
    void addAction(java.lang.Object,int) -> a
    void setClassName(java.lang.Object,java.lang.CharSequence) -> a
    void setScrollable(java.lang.Object,boolean) -> a
android.support.v4.view.accessibility.AccessibilityNodeInfoCompatIcs -> android.support.v4.view.a.f:
    void addAction(java.lang.Object,int) -> a
    void setClassName(java.lang.Object,java.lang.CharSequence) -> a
    void setScrollable(java.lang.Object,boolean) -> a
android.support.v4.view.accessibility.AccessibilityNodeProviderCompat -> android.support.v4.view.a.g:
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat$AccessibilityNodeProviderImpl IMPL -> a
    java.lang.Object mProvider -> b
    java.lang.Object getProvider() -> a
    android.support.v4.view.accessibility.AccessibilityNodeInfoCompat createAccessibilityNodeInfo(int) -> a
    boolean performAction(int,int,android.os.Bundle) -> a
    java.util.List findAccessibilityNodeInfosByText(java.lang.String,int) -> a
android.support.v4.view.accessibility.AccessibilityNodeProviderCompat$AccessibilityNodeProviderImpl -> android.support.v4.view.a.h:
    java.lang.Object newAccessibilityNodeProviderBridge(android.support.v4.view.accessibility.AccessibilityNodeProviderCompat) -> a
android.support.v4.view.accessibility.AccessibilityNodeProviderCompat$AccessibilityNodeProviderJellyBeanImpl -> android.support.v4.view.a.i:
    java.lang.Object newAccessibilityNodeProviderBridge(android.support.v4.view.accessibility.AccessibilityNodeProviderCompat) -> a
android.support.v4.view.accessibility.AccessibilityNodeProviderCompat$AccessibilityNodeProviderJellyBeanImpl$1 -> android.support.v4.view.a.j:
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat val$compat -> a
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompat$AccessibilityNodeProviderJellyBeanImpl this$0 -> b
    boolean performAction(int,int,android.os.Bundle) -> a
    java.util.List findAccessibilityNodeInfosByText(java.lang.String,int) -> a
    java.lang.Object createAccessibilityNodeInfo(int) -> a
android.support.v4.view.accessibility.AccessibilityNodeProviderCompat$AccessibilityNodeProviderStubImpl -> android.support.v4.view.a.k:
    java.lang.Object newAccessibilityNodeProviderBridge(android.support.v4.view.accessibility.AccessibilityNodeProviderCompat) -> a
android.support.v4.view.accessibility.AccessibilityNodeProviderCompatJellyBean -> android.support.v4.view.a.l:
    java.lang.Object newAccessibilityNodeProviderBridge(android.support.v4.view.accessibility.AccessibilityNodeProviderCompatJellyBean$AccessibilityNodeInfoBridge) -> a
android.support.v4.view.accessibility.AccessibilityNodeProviderCompatJellyBean$1 -> android.support.v4.view.a.m:
    android.support.v4.view.accessibility.AccessibilityNodeProviderCompatJellyBean$AccessibilityNodeInfoBridge val$bridge -> a
    android.view.accessibility.AccessibilityNodeInfo createAccessibilityNodeInfo(int) -> createAccessibilityNodeInfo
    java.util.List findAccessibilityNodeInfosByText(java.lang.String,int) -> findAccessibilityNodeInfosByText
    boolean performAction(int,int,android.os.Bundle) -> performAction
android.support.v4.view.accessibility.AccessibilityNodeProviderCompatJellyBean$AccessibilityNodeInfoBridge -> android.support.v4.view.a.n:
    java.lang.Object createAccessibilityNodeInfo(int) -> a
    boolean performAction(int,int,android.os.Bundle) -> a
    java.util.List findAccessibilityNodeInfosByText(java.lang.String,int) -> a
android.support.v4.widget.DrawerLayout -> android.support.v4.widget.DrawerLayout:
    int[] LAYOUT_ATTRS -> a
    int mMinDrawerMargin -> b
    int mScrimColor -> c
    float mScrimOpacity -> d
    android.graphics.Paint mScrimPaint -> e
    android.support.v4.widget.ViewDragHelper mLeftDragger -> f
    android.support.v4.widget.ViewDragHelper mRightDragger -> g
    android.support.v4.widget.DrawerLayout$ViewDragCallback mLeftCallback -> h
    android.support.v4.widget.DrawerLayout$ViewDragCallback mRightCallback -> i
    int mDrawerState -> j
    boolean mInLayout -> k
    boolean mFirstLayout -> l
    int mLockModeLeft -> m
    int mLockModeRight -> n
    boolean mDisallowInterceptRequested -> o
    boolean mChildrenCanceledTouch -> p
    android.support.v4.widget.DrawerLayout$DrawerListener mListener -> q
    float mInitialMotionX -> r
    float mInitialMotionY -> s
    android.graphics.drawable.Drawable mShadowLeft -> t
    android.graphics.drawable.Drawable mShadowRight -> u
    void setScrimColor(int) -> setScrimColor
    void setDrawerListener(android.support.v4.widget.DrawerLayout$DrawerListener) -> setDrawerListener
    void setDrawerLockMode(int) -> setDrawerLockMode
    void setDrawerLockMode(int,int) -> a
    int getDrawerLockMode(android.view.View) -> a
    void updateDrawerState(int,int,android.view.View) -> a
    void dispatchOnDrawerClosed(android.view.View) -> b
    void dispatchOnDrawerOpened(android.view.View) -> c
    void dispatchOnDrawerSlide(android.view.View,float) -> a
    void setDrawerViewOffset(android.view.View,float) -> b
    float getDrawerViewOffset(android.view.View) -> d
    int getDrawerViewGravity(android.view.View) -> e
    boolean checkDrawerViewGravity(android.view.View,int) -> a
    android.view.View findOpenDrawer() -> a
    android.view.View findDrawerWithGravity(int) -> a
    java.lang.String gravityToString(int) -> b
    void onDetachedFromWindow() -> onDetachedFromWindow
    void onAttachedToWindow() -> onAttachedToWindow
    void onMeasure(int,int) -> onMeasure
    void onLayout(boolean,int,int,int,int) -> onLayout
    void requestLayout() -> requestLayout
    void computeScroll() -> computeScroll
    boolean hasOpaqueBackground(android.view.View) -> k
    boolean drawChild(android.graphics.Canvas,android.view.View,long) -> drawChild
    boolean isContentView(android.view.View) -> f
    boolean isDrawerView(android.view.View) -> g
    boolean onInterceptTouchEvent(android.view.MotionEvent) -> onInterceptTouchEvent
    boolean onTouchEvent(android.view.MotionEvent) -> onTouchEvent
    void requestDisallowInterceptTouchEvent(boolean) -> requestDisallowInterceptTouchEvent
    void closeDrawers() -> b
    void closeDrawers(boolean) -> a
    void openDrawer(android.view.View) -> h
    void closeDrawer(android.view.View) -> i
    boolean isDrawerVisible(android.view.View) -> j
    boolean hasPeekingDrawer() -> d
    android.view.ViewGroup$LayoutParams generateDefaultLayoutParams() -> generateDefaultLayoutParams
    android.view.ViewGroup$LayoutParams generateLayoutParams(android.view.ViewGroup$LayoutParams) -> generateLayoutParams
    boolean checkLayoutParams(android.view.ViewGroup$LayoutParams) -> checkLayoutParams
    android.view.ViewGroup$LayoutParams generateLayoutParams(android.util.AttributeSet) -> generateLayoutParams
    boolean hasVisibleDrawer() -> e
    android.view.View findVisibleDrawer() -> f
    boolean onKeyDown(int,android.view.KeyEvent) -> onKeyDown
    boolean onKeyUp(int,android.view.KeyEvent) -> onKeyUp
    void onRestoreInstanceState(android.os.Parcelable) -> onRestoreInstanceState
    android.os.Parcelable onSaveInstanceState() -> onSaveInstanceState
    int[] access$100() -> c
android.support.v4.widget.DrawerLayout$DrawerListener -> android.support.v4.widget.a:
    void onDrawerSlide(android.view.View,float) -> a
    void onDrawerOpened(android.view.View) -> a
    void onDrawerClosed(android.view.View) -> b
    void onDrawerStateChanged(int) -> a
android.support.v4.widget.DrawerLayout$LayoutParams -> android.support.v4.widget.b:
    int gravity -> a
    float onScreen -> b
    boolean isPeeking -> c
    boolean knownOpen -> d
android.support.v4.widget.DrawerLayout$SavedState -> android.support.v4.widget.DrawerLayout$SavedState:
    int openDrawerGravity -> a
    int lockModeLeft -> b
    int lockModeRight -> c
    android.os.Parcelable$Creator CREATOR -> CREATOR
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
android.support.v4.widget.DrawerLayout$SavedState$1 -> android.support.v4.widget.c:
    android.support.v4.widget.DrawerLayout$SavedState createFromParcel(android.os.Parcel) -> a
    android.support.v4.widget.DrawerLayout$SavedState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.widget.DrawerLayout$ViewDragCallback -> android.support.v4.widget.d:
    int mGravity -> b
    android.support.v4.widget.ViewDragHelper mDragger -> c
    java.lang.Runnable mPeekRunnable -> d
    android.support.v4.widget.DrawerLayout this$0 -> a
    void removeCallbacks() -> a
    boolean tryCaptureView(android.view.View,int) -> a
    void onViewDragStateChanged(int) -> a
    void onViewPositionChanged(android.view.View,int,int,int,int) -> a
    void onViewCaptured(android.view.View,int) -> b
    void closeOtherDrawer() -> b
    void onViewReleased(android.view.View,float,float) -> a
    void onEdgeTouched(int,int) -> a
    boolean onEdgeLock(int) -> b
    void onEdgeDragStarted(int,int) -> b
    int getViewHorizontalDragRange(android.view.View) -> a
    int clampViewPositionHorizontal(android.view.View,int,int) -> a
    int clampViewPositionVertical(android.view.View,int,int) -> b
android.support.v4.widget.EdgeEffectCompat -> android.support.v4.widget.e:
    java.lang.Object mEdgeEffect -> a
    android.support.v4.widget.EdgeEffectCompat$EdgeEffectImpl IMPL -> b
    void setSize(int,int) -> a
    boolean isFinished() -> a
    void finish() -> b
    boolean onPull(float) -> a
    boolean onRelease() -> c
    boolean draw(android.graphics.Canvas) -> a
android.support.v4.widget.EdgeEffectCompat$BaseEdgeEffectImpl -> android.support.v4.widget.f:
    java.lang.Object newEdgeEffect(android.content.Context) -> a
    void setSize(java.lang.Object,int,int) -> a
    boolean isFinished(java.lang.Object) -> a
    void finish(java.lang.Object) -> b
    boolean onPull(java.lang.Object,float) -> a
    boolean onRelease(java.lang.Object) -> c
    boolean draw(java.lang.Object,android.graphics.Canvas) -> a
android.support.v4.widget.EdgeEffectCompat$EdgeEffectIcsImpl -> android.support.v4.widget.g:
    java.lang.Object newEdgeEffect(android.content.Context) -> a
    void setSize(java.lang.Object,int,int) -> a
    boolean isFinished(java.lang.Object) -> a
    void finish(java.lang.Object) -> b
    boolean onPull(java.lang.Object,float) -> a
    boolean onRelease(java.lang.Object) -> c
    boolean draw(java.lang.Object,android.graphics.Canvas) -> a
android.support.v4.widget.EdgeEffectCompat$EdgeEffectImpl -> android.support.v4.widget.h:
    java.lang.Object newEdgeEffect(android.content.Context) -> a
    void setSize(java.lang.Object,int,int) -> a
    boolean isFinished(java.lang.Object) -> a
    void finish(java.lang.Object) -> b
    boolean onPull(java.lang.Object,float) -> a
    boolean onRelease(java.lang.Object) -> c
    boolean draw(java.lang.Object,android.graphics.Canvas) -> a
android.support.v4.widget.EdgeEffectCompatIcs -> android.support.v4.widget.i:
    java.lang.Object newEdgeEffect(android.content.Context) -> a
    void setSize(java.lang.Object,int,int) -> a
    boolean isFinished(java.lang.Object) -> a
    void finish(java.lang.Object) -> b
    boolean onPull(java.lang.Object,float) -> a
    boolean onRelease(java.lang.Object) -> c
    boolean draw(java.lang.Object,android.graphics.Canvas) -> a
android.support.v4.widget.ScrollerCompat -> android.support.v4.widget.j:
    java.lang.Object mScroller -> a
    android.support.v4.widget.ScrollerCompat$ScrollerCompatImpl IMPL -> b
    boolean isFinished() -> a
    int getCurrX() -> b
    int getCurrY() -> c
    int getFinalX() -> d
    int getFinalY() -> e
    boolean computeScrollOffset() -> f
    void startScroll(int,int,int,int,int) -> a
    void abortAnimation() -> g
android.support.v4.widget.ScrollerCompat$ScrollerCompatImpl -> android.support.v4.widget.k:
    boolean isFinished(java.lang.Object) -> a
    int getCurrX(java.lang.Object) -> b
    int getCurrY(java.lang.Object) -> c
    boolean computeScrollOffset(java.lang.Object) -> d
    void startScroll(java.lang.Object,int,int,int,int,int) -> a
    void abortAnimation(java.lang.Object) -> e
    int getFinalX(java.lang.Object) -> f
    int getFinalY(java.lang.Object) -> g
android.support.v4.widget.ScrollerCompat$ScrollerCompatImplBase -> android.support.v4.widget.l:
    boolean isFinished(java.lang.Object) -> a
    int getCurrX(java.lang.Object) -> b
    int getCurrY(java.lang.Object) -> c
    boolean computeScrollOffset(java.lang.Object) -> d
    void startScroll(java.lang.Object,int,int,int,int,int) -> a
    void abortAnimation(java.lang.Object) -> e
    int getFinalX(java.lang.Object) -> f
    int getFinalY(java.lang.Object) -> g
android.support.v4.widget.ScrollerCompat$ScrollerCompatImplGingerbread -> android.support.v4.widget.m:
    boolean isFinished(java.lang.Object) -> a
    int getCurrX(java.lang.Object) -> b
    int getCurrY(java.lang.Object) -> c
    boolean computeScrollOffset(java.lang.Object) -> d
    void startScroll(java.lang.Object,int,int,int,int,int) -> a
    void abortAnimation(java.lang.Object) -> e
    int getFinalX(java.lang.Object) -> f
    int getFinalY(java.lang.Object) -> g
android.support.v4.widget.ScrollerCompat$ScrollerCompatImplIcs -> android.support.v4.widget.n:
android.support.v4.widget.ScrollerCompatGingerbread -> android.support.v4.widget.o:
    boolean isFinished(java.lang.Object) -> a
    int getCurrX(java.lang.Object) -> b
    int getCurrY(java.lang.Object) -> c
    boolean computeScrollOffset(java.lang.Object) -> d
    void startScroll(java.lang.Object,int,int,int,int,int) -> a
    void abortAnimation(java.lang.Object) -> e
    int getFinalX(java.lang.Object) -> f
    int getFinalY(java.lang.Object) -> g
android.support.v4.widget.SlidingPaneLayout -> android.support.v4.widget.SlidingPaneLayout:
    int mSliderFadeColor -> b
    int mCoveredFadeColor -> c
    android.graphics.drawable.Drawable mShadowDrawable -> d
    int mOverhangSize -> e
    boolean mCanSlide -> f
    android.view.View mSlideableView -> g
    float mSlideOffset -> h
    float mParallaxOffset -> i
    int mSlideRange -> j
    boolean mIsUnableToDrag -> k
    int mParallaxBy -> l
    float mInitialMotionX -> m
    float mInitialMotionY -> n
    android.support.v4.widget.SlidingPaneLayout$PanelSlideListener mPanelSlideListener -> o
    android.support.v4.widget.ViewDragHelper mDragHelper -> p
    boolean mPreservedOpenState -> q
    boolean mFirstLayout -> r
    android.graphics.Rect mTmpRect -> s
    java.util.ArrayList mPostedRunnables -> t
    android.support.v4.widget.SlidingPaneLayout$SlidingPanelLayoutImpl IMPL -> a
    void setParallaxDistance(int) -> setParallaxDistance
    int getParallaxDistance() -> getParallaxDistance
    void setSliderFadeColor(int) -> setSliderFadeColor
    int getSliderFadeColor() -> getSliderFadeColor
    void setCoveredFadeColor(int) -> setCoveredFadeColor
    int getCoveredFadeColor() -> getCoveredFadeColor
    void setPanelSlideListener(android.support.v4.widget.SlidingPaneLayout$PanelSlideListener) -> setPanelSlideListener
    void updateObscuredViewsVisibility(android.view.View) -> a
    void setAllChildrenVisible() -> a
    boolean hasOpaqueBackground(android.view.View) -> c
    void onAttachedToWindow() -> onAttachedToWindow
    void onDetachedFromWindow() -> onDetachedFromWindow
    void onMeasure(int,int) -> onMeasure
    void onLayout(boolean,int,int,int,int) -> onLayout
    void onSizeChanged(int,int,int,int) -> onSizeChanged
    void requestChildFocus(android.view.View,android.view.View) -> requestChildFocus
    boolean onInterceptTouchEvent(android.view.MotionEvent) -> onInterceptTouchEvent
    boolean onTouchEvent(android.view.MotionEvent) -> onTouchEvent
    boolean closePane(android.view.View,int) -> a
    boolean openPane(android.view.View,int) -> b
    boolean openPane() -> b
    boolean closePane() -> c
    boolean isOpen() -> d
    boolean isSlideable() -> e
    void dimChildView(android.view.View,float,int) -> a
    boolean drawChild(android.graphics.Canvas,android.view.View,long) -> drawChild
    void invalidateChildRegion(android.view.View) -> d
    boolean smoothSlideTo(float,int) -> a
    void computeScroll() -> computeScroll
    void setShadowDrawable(android.graphics.drawable.Drawable) -> setShadowDrawable
    void setShadowResource(int) -> setShadowResource
    void draw(android.graphics.Canvas) -> draw
    void parallaxOtherViews(float) -> a
    boolean isDimmed(android.view.View) -> b
    android.view.ViewGroup$LayoutParams generateDefaultLayoutParams() -> generateDefaultLayoutParams
    android.view.ViewGroup$LayoutParams generateLayoutParams(android.view.ViewGroup$LayoutParams) -> generateLayoutParams
    boolean checkLayoutParams(android.view.ViewGroup$LayoutParams) -> checkLayoutParams
    android.view.ViewGroup$LayoutParams generateLayoutParams(android.util.AttributeSet) -> generateLayoutParams
    android.os.Parcelable onSaveInstanceState() -> onSaveInstanceState
    void onRestoreInstanceState(android.os.Parcelable) -> onRestoreInstanceState
    void access$900(android.support.v4.widget.SlidingPaneLayout,android.view.View) -> a
    java.util.ArrayList access$1000(android.support.v4.widget.SlidingPaneLayout) -> a
android.support.v4.widget.SlidingPaneLayout$1 -> android.support.v4.widget.p:
android.support.v4.widget.SlidingPaneLayout$DisableLayerRunnable -> android.support.v4.widget.q:
    android.view.View mChildView -> a
    android.support.v4.widget.SlidingPaneLayout this$0 -> b
    void run() -> run
android.support.v4.widget.SlidingPaneLayout$LayoutParams -> android.support.v4.widget.r:
    int[] ATTRS -> e
    float weight -> a
    boolean slideable -> b
    boolean dimWhenOffset -> c
    android.graphics.Paint dimPaint -> d
android.support.v4.widget.SlidingPaneLayout$PanelSlideListener -> android.support.v4.widget.s:
android.support.v4.widget.SlidingPaneLayout$SavedState -> android.support.v4.widget.SlidingPaneLayout$SavedState:
    boolean isOpen -> a
    android.os.Parcelable$Creator CREATOR -> CREATOR
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
android.support.v4.widget.SlidingPaneLayout$SavedState$1 -> android.support.v4.widget.t:
    android.support.v4.widget.SlidingPaneLayout$SavedState createFromParcel(android.os.Parcel) -> a
    android.support.v4.widget.SlidingPaneLayout$SavedState[] newArray(int) -> a
    java.lang.Object[] newArray(int) -> newArray
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
android.support.v4.widget.SlidingPaneLayout$SlidingPanelLayoutImpl -> android.support.v4.widget.u:
    void invalidateChildRegion(android.support.v4.widget.SlidingPaneLayout,android.view.View) -> a
android.support.v4.widget.SlidingPaneLayout$SlidingPanelLayoutImplBase -> android.support.v4.widget.v:
    void invalidateChildRegion(android.support.v4.widget.SlidingPaneLayout,android.view.View) -> a
android.support.v4.widget.SlidingPaneLayout$SlidingPanelLayoutImplJB -> android.support.v4.widget.w:
    java.lang.reflect.Method mGetDisplayList -> a
    java.lang.reflect.Field mRecreateDisplayList -> b
    void invalidateChildRegion(android.support.v4.widget.SlidingPaneLayout,android.view.View) -> a
android.support.v4.widget.SlidingPaneLayout$SlidingPanelLayoutImplJBMR1 -> android.support.v4.widget.x:
    void invalidateChildRegion(android.support.v4.widget.SlidingPaneLayout,android.view.View) -> a
android.support.v4.widget.ViewDragHelper -> android.support.v4.widget.y:
    int mDragState -> a
    int mTouchSlop -> b
    int mActivePointerId -> c
    float[] mInitialMotionX -> d
    float[] mInitialMotionY -> e
    float[] mLastMotionX -> f
    float[] mLastMotionY -> g
    int[] mInitialEdgesTouched -> h
    int[] mEdgeDragsInProgress -> i
    int[] mEdgeDragsLocked -> j
    int mPointersDown -> k
    android.view.VelocityTracker mVelocityTracker -> l
    float mMaxVelocity -> m
    float mMinVelocity -> n
    int mEdgeSize -> o
    int mTrackingEdges -> p
    android.support.v4.widget.ScrollerCompat mScroller -> q
    android.support.v4.widget.ViewDragHelper$Callback mCallback -> r
    android.view.View mCapturedView -> s
    boolean mReleaseInProgress -> t
    android.view.ViewGroup mParentView -> u
    android.view.animation.Interpolator sInterpolator -> v
    java.lang.Runnable mSetIdleRunnable -> w
    int getViewDragState() -> a
    int getEdgeSize() -> b
    void captureChildView(android.view.View,int) -> a
    android.view.View getCapturedView() -> c
    int getTouchSlop() -> d
    void cancel() -> e
    void abort() -> f
    boolean smoothSlideViewTo(android.view.View,int,int) -> a
    boolean settleCapturedViewAt(int,int) -> a
    boolean forceSettleCapturedViewAt(int,int,int,int) -> a
    int computeSettleDuration(android.view.View,int,int,int,int) -> a
    int computeAxisDuration(int,int,int) -> a
    int clampMag(int,int,int) -> b
    float clampMag(float,float,float) -> a
    float distanceInfluenceForSnapDuration(float) -> a
    boolean continueSettling(boolean) -> a
    void dispatchViewReleased(float,float) -> a
    void clearMotionHistory() -> g
    void clearMotionHistory(int) -> e
    void ensureMotionHistorySizeForId(int) -> f
    void saveInitialMotion(float,float,int) -> a
    void saveLastMotion(android.view.MotionEvent) -> c
    boolean isPointerDown(int) -> a
    void setDragState(int) -> b
    boolean tryCaptureViewForDrag(android.view.View,int) -> b
    boolean shouldInterceptTouchEvent(android.view.MotionEvent) -> a
    void processTouchEvent(android.view.MotionEvent) -> b
    void reportNewEdgeDrags(float,float,int) -> b
    boolean checkNewEdgeDrag(float,float,int,int) -> a
    boolean checkTouchSlop(android.view.View,float,float) -> a
    boolean checkTouchSlop(int) -> c
    boolean checkTouchSlop(int,int) -> b
    boolean isEdgeTouched(int) -> d
    boolean isEdgeTouched(int,int) -> c
    void releaseViewForPointerUp() -> h
    void dragTo(int,int,int,int) -> b
    boolean isCapturedViewUnder(int,int) -> d
    boolean isViewUnder(android.view.View,int,int) -> b
    android.view.View findTopChildUnder(int,int) -> e
    int getEdgesTouched(int,int) -> f
android.support.v4.widget.ViewDragHelper$1 -> android.support.v4.widget.z:
    float getInterpolation(float) -> getInterpolation
android.support.v4.widget.ViewDragHelper$Callback -> android.support.v4.widget.aa:
    void onViewDragStateChanged(int) -> a
    void onViewPositionChanged(android.view.View,int,int,int,int) -> a
    void onViewCaptured(android.view.View,int) -> b
    void onViewReleased(android.view.View,float,float) -> a
    void onEdgeTouched(int,int) -> a
    boolean onEdgeLock(int) -> b
    void onEdgeDragStarted(int,int) -> b
    int getOrderedChildIndex(int) -> c
    int getViewHorizontalDragRange(android.view.View) -> a
    int getViewVerticalDragRange(android.view.View) -> b
    boolean tryCaptureView(android.view.View,int) -> a
    int clampViewPositionHorizontal(android.view.View,int,int) -> a
    int clampViewPositionVertical(android.view.View,int,int) -> b
com.appkefu.appkehu_2.AppApplication -> com.appkefu.appkehu_2.AppApplication:
    boolean mIsConnected -> a
    void onCreate() -> onCreate
    void onTerminate() -> onTerminate
    boolean isConnected() -> a
    void setConnected(boolean) -> a
com.appkefu.appkehu_2.LoginActivity -> com.appkefu.appkehu_2.LoginActivity:
    java.lang.String TAG -> a
    com.appkefu.lib.service.XmppFacade mXmppFacade -> b
    android.os.AsyncTask mLoginTask -> c
    boolean mBinded -> d
    java.lang.String selfDefinedUserId -> e
    android.content.ServiceConnection conn -> f
    void onCreate(android.os.Bundle) -> onCreate
    void onStart() -> onStart
    void onRestart() -> onRestart
    void onResume() -> onResume
    void onPause() -> onPause
    void onStop() -> onStop
    void onDestroy() -> onDestroy
    java.lang.String access$0() -> a
    void access$1(com.appkefu.appkehu_2.LoginActivity,com.appkefu.lib.service.XmppFacade) -> a
    android.os.AsyncTask access$2(com.appkefu.appkehu_2.LoginActivity) -> a
    com.appkefu.lib.service.XmppFacade access$3(com.appkefu.appkehu_2.LoginActivity) -> b
    void access$4(com.appkefu.appkehu_2.LoginActivity,boolean) -> a
com.appkefu.appkehu_2.LoginActivity$1 -> com.appkefu.appkehu_2.a:
    com.appkefu.appkehu_2.LoginActivity this$0 -> a
    void onServiceDisconnected(android.content.ComponentName) -> onServiceDisconnected
    void onServiceConnected(android.content.ComponentName,android.os.IBinder) -> onServiceConnected
com.appkefu.appkehu_2.LoginActivity$LoginTask -> com.appkefu.appkehu_2.b:
    java.lang.String mVisitorName -> b
    com.appkefu.appkehu_2.LoginActivity this$0 -> a
    java.lang.Boolean doInBackground(com.appkefu.lib.service.XmppFacade[]) -> a
    void onPostExecute(java.lang.Boolean) -> a
    void onCancelled() -> onCancelled
    void onPostExecute(java.lang.Object) -> onPostExecute
com.appkefu.appkehu_2.TravelTicketsActivity -> com.appkefu.appkehu_2.TravelTicketsActivity:
    java.lang.String TAG -> a
    com.appkefu.appkehu_2.AppApplication app -> b
    android.widget.ImageButton chatButton -> c
    android.view.View$OnClickListener listener -> d
    void onCreate(android.os.Bundle) -> onCreate
    void onStart() -> onStart
    void onActivityResult(int,int,android.content.Intent) -> onActivityResult
    void onRestart() -> onRestart
    void onResume() -> onResume
    void onPause() -> onPause
    void onStop() -> onStop
    void onDestroy() -> onDestroy
    void startChat(java.lang.String,java.lang.String) -> a
    void access$0(com.appkefu.appkehu_2.TravelTicketsActivity,java.lang.String,java.lang.String) -> a
com.appkefu.appkehu_2.TravelTicketsActivity$1 -> com.appkefu.appkehu_2.c:
    com.appkefu.appkehu_2.TravelTicketsActivity this$0 -> a
    void onClick(android.view.View) -> onClick
com.appkefu.lib.ChatViewActivity -> com.appkefu.lib.ChatViewActivity:
    java.lang.String TAG -> d
    android.os.Handler mHandler -> e
    android.widget.Button mBtnSend -> f
    android.widget.Button mBtnBack -> g
    android.widget.ImageButton mBtnClear -> h
    android.widget.TextView mChatName -> i
    android.widget.EditText mEditTextContent -> j
    android.widget.ListView mListView -> k
    com.appkefu.lib.ChatViewMsgAdapter mAdapter -> l
    java.util.List mDataArrays -> m
    org.jivesoftware.smack.ChatManager mChatManager -> n
    org.jivesoftware.smack.Chat newChat -> o
    com.appkefu.lib.service.Contact mContact -> p
    java.lang.String chatName -> q
    com.appkefu.lib.service.XmppFacade mXmppFacade -> r
    boolean mBinded -> s
    android.os.Vibrator vibrator -> t
    java.lang.String mVisitorName -> u
    android.widget.TextView mBtnRcd -> v
    android.widget.RelativeLayout mBottom -> w
    android.widget.LinearLayout voice_rcd_hint_loading -> x
    android.widget.LinearLayout voice_rcd_hint_rcding -> y
    android.widget.LinearLayout voice_rcd_hint_tooshort -> z
    android.widget.ImageView img1 -> A
    android.widget.ImageView sc_img1 -> B
    com.appkefu.lib.SoundMeter mSensor -> C
    android.view.View rcChat_popup -> D
    android.widget.LinearLayout del_re -> E
    android.widget.ImageView chatting_mode_btn -> F
    android.widget.ImageView volume -> G
    boolean btn_vocie -> H
    int flag -> I
    java.lang.String voiceName -> J
    long startVoiceT -> K
    long endVoiceT -> L
    boolean isShosrt -> M
    android.widget.ImageView biaoqingBtn -> N
    android.widget.ImageView biaoqingfocuseBtn -> O
    android.support.v4.view.ViewPager viewPager -> P
    java.util.ArrayList grids -> Q
    int[] expressionImages -> R
    java.lang.String[] expressionImageNames -> S
    int[] expressionImages1 -> T
    java.lang.String[] expressionImageNames1 -> U
    int[] expressionImages2 -> V
    java.lang.String[] expressionImageNames2 -> W
    android.widget.ImageView page0 -> X
    android.widget.ImageView page1 -> Y
    android.widget.ImageView page2 -> Z
    android.widget.GridView gView1 -> aa
    android.widget.GridView gView2 -> ab
    android.widget.GridView gView3 -> ac
    android.widget.LinearLayout page_select -> ad
    int[] expressionImgs -> a
    int[] expressionImgs1 -> b
    int[] expressionImgs2 -> c
    android.view.View$OnClickListener listener -> ae
    android.content.ServiceConnection conn -> af
    java.lang.Runnable mSleepTask -> ag
    java.lang.Runnable mPollTask -> ah
    void onCreate(android.os.Bundle) -> onCreate
    void initViewPager() -> d
    void onStart() -> onStart
    void onRestart() -> onRestart
    void onResume() -> onResume
    void onPause() -> onPause
    void onStop() -> onStop
    void onDestroy() -> onDestroy
    java.lang.String faceToCN(java.lang.String) -> a
    void sendMessage() -> a
    void clearMessage() -> b
    boolean onTouchEvent(android.view.MotionEvent) -> onTouchEvent
    void start(java.lang.String) -> b
    void stop() -> e
    void updateDisplay(double) -> a
    android.widget.ImageView access$0(com.appkefu.lib.ChatViewActivity) -> a
    android.widget.ImageView access$1(com.appkefu.lib.ChatViewActivity) -> b
    android.support.v4.view.ViewPager access$2(com.appkefu.lib.ChatViewActivity) -> c
    android.widget.LinearLayout access$3(com.appkefu.lib.ChatViewActivity) -> d
    java.lang.String access$4() -> c
    void access$5(com.appkefu.lib.ChatViewActivity,com.appkefu.lib.service.XmppFacade) -> a
    void access$6(com.appkefu.lib.ChatViewActivity,boolean) -> a
    com.appkefu.lib.service.XmppFacade access$7(com.appkefu.lib.ChatViewActivity) -> e
    void access$8(com.appkefu.lib.ChatViewActivity,org.jivesoftware.smack.ChatManager) -> a
    org.jivesoftware.smack.ChatManager access$9(com.appkefu.lib.ChatViewActivity) -> f
    com.appkefu.lib.service.Contact access$10(com.appkefu.lib.ChatViewActivity) -> g
    android.os.Handler access$11(com.appkefu.lib.ChatViewActivity) -> h
    java.lang.String access$12(com.appkefu.lib.ChatViewActivity) -> i
    java.util.List access$13(com.appkefu.lib.ChatViewActivity) -> j
    com.appkefu.lib.ChatViewMsgAdapter access$14(com.appkefu.lib.ChatViewActivity) -> k
    android.widget.ListView access$15(com.appkefu.lib.ChatViewActivity) -> l
    void access$16(com.appkefu.lib.ChatViewActivity,android.os.Vibrator) -> a
    android.os.Vibrator access$17(com.appkefu.lib.ChatViewActivity) -> m
    void access$18(com.appkefu.lib.ChatViewActivity,org.jivesoftware.smack.Chat) -> a
    void access$19(com.appkefu.lib.ChatViewActivity) -> n
    com.appkefu.lib.SoundMeter access$20(com.appkefu.lib.ChatViewActivity) -> o
    void access$21(com.appkefu.lib.ChatViewActivity,double) -> a
    java.lang.Runnable access$22(com.appkefu.lib.ChatViewActivity) -> p
    android.widget.ImageView access$23(com.appkefu.lib.ChatViewActivity) -> q
    android.widget.ImageView access$24(com.appkefu.lib.ChatViewActivity) -> r
    android.widget.ImageView access$25(com.appkefu.lib.ChatViewActivity) -> s
    int[] access$26(com.appkefu.lib.ChatViewActivity) -> t
    android.widget.GridView access$27(com.appkefu.lib.ChatViewActivity) -> u
    java.lang.String[] access$28(com.appkefu.lib.ChatViewActivity) -> v
    android.widget.EditText access$29(com.appkefu.lib.ChatViewActivity) -> w
    int[] access$30(com.appkefu.lib.ChatViewActivity) -> x
    android.widget.GridView access$31(com.appkefu.lib.ChatViewActivity) -> y
    java.lang.String[] access$32(com.appkefu.lib.ChatViewActivity) -> z
    org.jivesoftware.smack.Chat access$33(com.appkefu.lib.ChatViewActivity) -> A
    boolean access$34(com.appkefu.lib.ChatViewActivity) -> B
    android.widget.TextView access$35(com.appkefu.lib.ChatViewActivity) -> C
    android.widget.RelativeLayout access$36(com.appkefu.lib.ChatViewActivity) -> D
    void access$37(com.appkefu.lib.ChatViewActivity,boolean) -> b
    android.widget.ImageView access$38(com.appkefu.lib.ChatViewActivity) -> E
    int[] access$39(com.appkefu.lib.ChatViewActivity) -> F
    java.lang.String[] access$40(com.appkefu.lib.ChatViewActivity) -> G
    java.util.ArrayList access$41(com.appkefu.lib.ChatViewActivity) -> H
    boolean access$42(com.appkefu.lib.ChatViewActivity) -> I
    android.widget.LinearLayout access$43(com.appkefu.lib.ChatViewActivity) -> J
    android.widget.LinearLayout access$44(com.appkefu.lib.ChatViewActivity) -> K
    android.widget.LinearLayout access$45(com.appkefu.lib.ChatViewActivity) -> L
    android.view.View access$46(com.appkefu.lib.ChatViewActivity) -> M
    void access$47(com.appkefu.lib.ChatViewActivity,boolean) -> c
com.appkefu.lib.ChatViewActivity$1 -> com.appkefu.lib.a:
    com.appkefu.lib.ChatViewActivity this$0 -> a
    void onClick(android.view.View) -> onClick
com.appkefu.lib.ChatViewActivity$10 -> com.appkefu.lib.b:
    com.appkefu.lib.ChatViewActivity this$0 -> a
    void run() -> run
com.appkefu.lib.ChatViewActivity$11 -> com.appkefu.lib.c:
    com.appkefu.lib.ChatViewActivity this$0 -> a
    void run() -> run
com.appkefu.lib.ChatViewActivity$2 -> com.appkefu.lib.d:
    com.appkefu.lib.ChatViewActivity this$0 -> a
    void onServiceDisconnected(android.content.ComponentName) -> onServiceDisconnected
    void onServiceConnected(android.content.ComponentName,android.os.IBinder) -> onServiceConnected
    com.appkefu.lib.ChatViewActivity access$0(com.appkefu.lib.ChatViewActivity$2) -> a
com.appkefu.lib.ChatViewActivity$2$1 -> com.appkefu.lib.e:
    com.appkefu.lib.ChatViewActivity$2 this$1 -> a
    void processMessage(org.jivesoftware.smack.Chat,org.jivesoftware.smack.packet.Message) -> a
    com.appkefu.lib.ChatViewActivity$2 access$0(com.appkefu.lib.ChatViewActivity$2$1) -> a
com.appkefu.lib.ChatViewActivity$2$1$1 -> com.appkefu.lib.f:
    com.appkefu.lib.ChatViewActivity$2$1 this$2 -> a
    org.jivesoftware.smack.packet.Message val$msg -> b
    void run() -> run
com.appkefu.lib.ChatViewActivity$3 -> com.appkefu.lib.g:
    com.appkefu.lib.ChatViewActivity this$0 -> a
    void run() -> run
com.appkefu.lib.ChatViewActivity$4 -> com.appkefu.lib.h:
    com.appkefu.lib.ChatViewActivity this$0 -> a
    void run() -> run
com.appkefu.lib.ChatViewActivity$5 -> com.appkefu.lib.i:
    com.appkefu.lib.ChatViewActivity this$0 -> a
    void onClick(android.view.View) -> onClick
com.appkefu.lib.ChatViewActivity$6 -> com.appkefu.lib.j:
    com.appkefu.lib.ChatViewActivity this$0 -> a
    boolean onTouch(android.view.View,android.view.MotionEvent) -> onTouch
com.appkefu.lib.ChatViewActivity$7 -> com.appkefu.lib.k:
    com.appkefu.lib.ChatViewActivity this$0 -> a
    void onItemClick(android.widget.AdapterView,android.view.View,int,long) -> onItemClick
com.appkefu.lib.ChatViewActivity$8 -> com.appkefu.lib.l:
    com.appkefu.lib.ChatViewActivity this$0 -> a
    boolean isViewFromObject(android.view.View,java.lang.Object) -> a
    int getCount() -> a
    void destroyItem(android.view.View,int,java.lang.Object) -> a
    java.lang.Object instantiateItem(android.view.View,int) -> a
com.appkefu.lib.ChatViewActivity$9 -> com.appkefu.lib.m:
    com.appkefu.lib.ChatViewActivity this$0 -> a
    void onClick(android.content.DialogInterface,int) -> onClick
com.appkefu.lib.ChatViewActivity$GuidePageChangeListener -> com.appkefu.lib.n:
    com.appkefu.lib.ChatViewActivity this$0 -> a
    void onPageScrollStateChanged(int) -> b
    void onPageScrolled(int,float,int) -> a
    void onPageSelected(int) -> a
    com.appkefu.lib.ChatViewActivity access$0(com.appkefu.lib.ChatViewActivity$GuidePageChangeListener) -> a
com.appkefu.lib.ChatViewActivity$GuidePageChangeListener$1 -> com.appkefu.lib.o:
    com.appkefu.lib.ChatViewActivity$GuidePageChangeListener this$1 -> a
    void onItemClick(android.widget.AdapterView,android.view.View,int,long) -> onItemClick
com.appkefu.lib.ChatViewActivity$GuidePageChangeListener$2 -> com.appkefu.lib.p:
    com.appkefu.lib.ChatViewActivity$GuidePageChangeListener this$1 -> a
    void onItemClick(android.widget.AdapterView,android.view.View,int,long) -> onItemClick
com.appkefu.lib.ChatViewActivity$UploadFileTask -> com.appkefu.lib.q:
    com.appkefu.lib.ChatViewActivity this$0 -> a
    java.lang.String doInBackground(java.lang.String[]) -> a
    void onPostExecute(java.lang.String) -> a
    void onPostExecute(java.lang.Object) -> onPostExecute
    java.lang.Object doInBackground(java.lang.Object[]) -> doInBackground
com.appkefu.lib.ChatViewMsgAdapter -> com.appkefu.lib.r:
    java.util.List coll -> a
    android.content.Context ctx -> b
    android.view.LayoutInflater mInflater -> c
    android.media.MediaPlayer mMediaPlayer -> d
    int getCount() -> getCount
    java.lang.Object getItem(int) -> getItem
    long getItemId(int) -> getItemId
    int getItemViewType(int) -> getItemViewType
    int getViewTypeCount() -> getViewTypeCount
    android.view.View getView(int,android.view.View,android.view.ViewGroup) -> getView
    void playMusic(java.lang.String) -> a
    void access$0(com.appkefu.lib.ChatViewMsgAdapter,java.lang.String) -> a
com.appkefu.lib.ChatViewMsgAdapter$1 -> com.appkefu.lib.s:
    com.appkefu.lib.ChatViewMsgAdapter this$0 -> a
    com.appkefu.lib.ChatViewMsgEntity val$entity -> b
    void onClick(android.view.View) -> onClick
com.appkefu.lib.ChatViewMsgAdapter$2 -> com.appkefu.lib.t:
    com.appkefu.lib.ChatViewMsgAdapter this$0 -> a
    void onCompletion(android.media.MediaPlayer) -> onCompletion
com.appkefu.lib.ChatViewMsgAdapter$ViewHolder -> com.appkefu.lib.u:
    android.widget.TextView tvSendTime -> a
    android.widget.TextView tvUserName -> b
    android.widget.TextView tvContent -> c
    android.widget.TextView tvTime -> d
    boolean isComMsg -> e
com.appkefu.lib.ChatViewMsgEntity -> com.appkefu.lib.v:
    java.lang.String name -> a
    java.lang.String date -> b
    java.lang.String text -> c
    int isSend -> d
    java.lang.String time -> e
    void setTime(java.lang.String) -> a
    java.lang.String getName() -> a
    void setName(java.lang.String) -> b
    java.lang.String getDate() -> b
    void setDate(java.lang.String) -> c
    java.lang.String getText() -> c
    void setText(java.lang.String) -> d
    int isSend() -> d
    void setSend(int) -> a
com.appkefu.lib.Database -> com.appkefu.lib.w:
    android.database.sqlite.SQLiteDatabase database -> a
    android.database.sqlite.SQLiteDatabase databaseRO -> b
com.appkefu.lib.DatabaseOpenHelper -> com.appkefu.lib.x:
    java.lang.String TAG -> a
    void onCreate(android.database.sqlite.SQLiteDatabase) -> onCreate
    void onUpgrade(android.database.sqlite.SQLiteDatabase,int,int) -> onUpgrade
com.appkefu.lib.MessageDatabase -> com.appkefu.lib.y:
    boolean addMessage(java.lang.String,java.lang.String,java.lang.String,int) -> a
    boolean addVoiceMessage(java.lang.String,java.lang.String,java.lang.String,java.lang.String,int) -> a
    boolean deleteMessages(java.lang.String) -> a
    java.util.ArrayList getFullDatabase(java.lang.String) -> b
    android.content.ContentValues composeValues(java.lang.String,java.lang.String,java.lang.String,int) -> b
    android.content.ContentValues composeVoiceValues(java.lang.String,java.lang.String,java.lang.String,java.lang.String,int) -> b
com.appkefu.lib.MessageHelper -> com.appkefu.lib.z:
    com.appkefu.lib.MessageHelper messageHelper -> a
    com.appkefu.lib.MessageHelper getMessageHelper(android.content.Context) -> a
    boolean addMessage(java.lang.String,java.lang.String,int) -> a
    boolean addVoiceMessage(java.lang.String,java.lang.String,java.lang.String,int) -> a
    boolean deleteMessages(java.lang.String) -> a
    java.util.ArrayList getAllMessages(java.lang.String) -> b
com.appkefu.lib.OpenUDID_manager -> com.appkefu.lib.aa:
    android.content.Context mContext -> a
    java.util.List mMatchingIntents -> b
    java.util.Map mReceivedOpenUDIDs -> c
    android.content.SharedPreferences mPreferences -> d
    java.util.Random mRandom -> e
    java.lang.String OpenUDID -> f
    boolean mInitialized -> g
    void onServiceConnected(android.content.ComponentName,android.os.IBinder) -> onServiceConnected
    void onServiceDisconnected(android.content.ComponentName) -> onServiceDisconnected
    void storeOpenUDID() -> c
    void generateOpenUDID() -> d
    void startService() -> e
    void getMostFrequentOpenUDID() -> f
    java.lang.String getOpenUDID() -> a
    boolean isInitialized() -> b
    void sync(android.content.Context) -> a
    java.util.Map access$0(com.appkefu.lib.OpenUDID_manager) -> a
com.appkefu.lib.OpenUDID_manager$ValueComparator -> com.appkefu.lib.ab:
    com.appkefu.lib.OpenUDID_manager this$0 -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
com.appkefu.lib.ResUtil -> com.appkefu.lib.ac:
    java.lang.String TAG -> a
    com.appkefu.lib.ResUtil instance -> b
    android.content.Context context -> c
    java.lang.Class id -> d
    java.lang.Class drawable -> e
    java.lang.Class layout -> f
    java.lang.Class anim -> g
    java.lang.Class style -> h
    java.lang.Class string -> i
    java.lang.Class array -> j
    com.appkefu.lib.ResUtil getResofR(android.content.Context) -> a
    int getAnim(java.lang.String) -> a
    int getId(java.lang.String) -> b
    int getDrawable(java.lang.String) -> c
    int getLayout(java.lang.String) -> d
    int getString(java.lang.String) -> e
    int getResofR(java.lang.Class,java.lang.String) -> a
com.appkefu.lib.SoundMeter -> com.appkefu.lib.ad:
    android.media.MediaRecorder mRecorder -> a
    double mEMA -> b
    void start(java.lang.String) -> a
    void stop() -> a
    double getAmplitude() -> b
com.appkefu.lib.Utils -> com.appkefu.lib.ae:
    java.lang.String TAG -> a
    java.lang.String getDate() -> a
com.appkefu.lib.service.AppService -> com.appkefu.lib.service.AppService:
    java.lang.String TAG -> a
    com.appkefu.lib.service.XmppFacade xmppFacade -> b
    android.app.NotificationManager mNotificationManager -> c
    void onCreate() -> onCreate
    void onStart(android.content.Intent,int) -> onStart
    int onStartCommand(android.content.Intent,int,int) -> onStartCommand
    void onDestroy() -> onDestroy
    android.os.IBinder onBind(android.content.Intent) -> onBind
    boolean onUnbind(android.content.Intent) -> onUnbind
    void onRebind(android.content.Intent) -> onRebind
    void sendNotification(int,android.app.Notification) -> a
    void configure(org.jivesoftware.smack.provider.ProviderManager) -> a
com.appkefu.lib.service.Contact -> com.appkefu.lib.service.Contact:
    android.os.Parcelable$Creator CREATOR -> CREATOR
    int mID -> a
    int mStatus -> b
    java.lang.String mJID -> c
    java.lang.String mSelectedRes -> d
    java.lang.String mMsgState -> e
    java.util.List mRes -> f
    java.util.List mGroups -> g
    java.lang.String mName -> h
    java.lang.String mAvatarId -> i
    android.net.Uri makeXmppUri(java.lang.String) -> a
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
    int describeContents() -> describeContents
    java.util.List getGroups() -> a
    java.lang.String getJID() -> b
    java.util.List getMRes() -> c
    java.lang.String getName() -> d
    java.lang.String toString() -> toString
    android.net.Uri toUri() -> e
    java.lang.String getJIDWithRes() -> f
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
com.appkefu.lib.service.Contact$1 -> com.appkefu.lib.service.a:
    com.appkefu.lib.service.Contact createFromParcel(android.os.Parcel) -> a
    com.appkefu.lib.service.Contact[] newArray(int) -> a
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
    java.lang.Object[] newArray(int) -> newArray
com.appkefu.lib.service.ExpressionUtil -> com.appkefu.lib.service.b:
    java.lang.String TAG -> a
    void dealExpression(android.content.Context,android.text.SpannableString,java.util.regex.Pattern,int) -> a
    android.text.SpannableString getExpressionString(android.content.Context,java.lang.String,java.lang.String) -> a
com.appkefu.lib.service.Expressions -> com.appkefu.lib.service.c:
    java.lang.String[] expressionImgNames -> a
    java.lang.String[] expressionImgNamesCn -> b
    java.lang.String[] expressionImgNames1 -> c
    java.lang.String[] expressionImgNamesCN1 -> d
    java.lang.String[] expressionImgNames2 -> e
    java.lang.String[] expressionImgNamesCN2 -> f
    java.lang.String[] expressionRegImgNames -> g
com.appkefu.lib.service.LoginAsyncTask -> com.appkefu.lib.service.d:
    java.lang.String TAG -> a
    java.lang.String mErrorMessage -> b
    void onCancelled() -> onCancelled
    java.lang.String getErrorMessage() -> a
    java.lang.Boolean doInBackground(com.appkefu.lib.service.XmppFacade[]) -> a
    java.lang.Object doInBackground(java.lang.Object[]) -> doInBackground
com.appkefu.lib.service.Message -> com.appkefu.lib.service.Message:
    android.os.Parcelable$Creator CREATOR -> CREATOR
    int mType -> a
    java.lang.String mBody -> b
    java.lang.String mSubject -> c
    java.lang.String mTo -> d
    java.lang.String mFrom -> e
    java.lang.String mThread -> f
    java.util.Date mTimestamp -> g
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
    int describeContents() -> describeContents
com.appkefu.lib.service.Message$1 -> com.appkefu.lib.service.e:
    com.appkefu.lib.service.Message createFromParcel(android.os.Parcel) -> a
    com.appkefu.lib.service.Message[] newArray(int) -> a
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
    java.lang.Object[] newArray(int) -> newArray
com.appkefu.lib.service.PresenceAdapter -> com.appkefu.lib.service.PresenceAdapter:
    android.os.Parcelable$Creator CREATOR -> CREATOR
    int mType -> a
    int mStatus -> b
    java.lang.String mTo -> c
    java.lang.String mFrom -> d
    java.lang.String mStatusText -> e
    int describeContents() -> describeContents
    void writeToParcel(android.os.Parcel,int) -> writeToParcel
com.appkefu.lib.service.PresenceAdapter$1 -> com.appkefu.lib.service.f:
    com.appkefu.lib.service.PresenceAdapter createFromParcel(android.os.Parcel) -> a
    com.appkefu.lib.service.PresenceAdapter[] newArray(int) -> a
    java.lang.Object createFromParcel(android.os.Parcel) -> createFromParcel
    java.lang.Object[] newArray(int) -> newArray
com.appkefu.lib.service.UsernameAndKefu -> com.appkefu.lib.service.g:
    java.lang.String username -> a
    java.lang.String kefuJID -> b
    java.lang.String getUsername() -> a
    void setUsername(java.lang.String) -> a
    java.lang.String getKefuJID() -> b
    void setKefuJID(java.lang.String) -> b
com.appkefu.lib.service.XmppFacade -> com.appkefu.lib.service.h:
    java.lang.String TAG -> a
    com.appkefu.lib.service.AppService appService -> b
    org.jivesoftware.smack.XMPPConnection mXmppConnection -> c
    org.jivesoftware.smack.ChatManager mChatManager -> d
    org.jivesoftware.smack.ChatManagerListener mChatManagerListener -> e
    org.jivesoftware.smack.ChatManager getChatManager() -> a
    org.jivesoftware.smack.XMPPConnection getXmppConnection() -> b
    void initXmppConnection() -> e
    boolean login(java.lang.String) -> a
    void saveCredential(java.lang.String,java.lang.String) -> a
    android.app.PendingIntent makeChatIntent(java.lang.String) -> b
    boolean validateAppkey() -> c
    java.lang.String access$0() -> d
    com.appkefu.lib.service.AppService access$1(com.appkefu.lib.service.XmppFacade) -> a
    android.app.PendingIntent access$2(com.appkefu.lib.service.XmppFacade,java.lang.String) -> a
com.appkefu.lib.service.XmppFacade$1 -> com.appkefu.lib.service.i:
    com.appkefu.lib.service.XmppFacade this$0 -> a
    void chatCreated(org.jivesoftware.smack.Chat,boolean) -> a
    com.appkefu.lib.service.XmppFacade access$0(com.appkefu.lib.service.XmppFacade$1) -> a
com.appkefu.lib.service.XmppFacade$1$1 -> com.appkefu.lib.service.j:
    com.appkefu.lib.service.XmppFacade$1 this$1 -> a
    void processMessage(org.jivesoftware.smack.Chat,org.jivesoftware.smack.packet.Message) -> a
com.novell.sasl.client.DigestChallenge -> com.a.a.a.a:
    java.util.ArrayList m_realms -> a
    java.lang.String m_nonce -> b
    int m_qop -> c
    boolean m_staleFlag -> d
    int m_maxBuf -> e
    java.lang.String m_characterSet -> f
    java.lang.String m_algorithm -> g
    int m_cipherOptions -> h
    void checkSemantics(com.novell.sasl.client.DirectiveList) -> a
    void handleNonce(com.novell.sasl.client.ParsedDirective) -> a
    void handleRealm(com.novell.sasl.client.ParsedDirective) -> b
    void handleQop(com.novell.sasl.client.ParsedDirective) -> c
    void handleMaxbuf(com.novell.sasl.client.ParsedDirective) -> d
    void handleCharset(com.novell.sasl.client.ParsedDirective) -> e
    void handleAlgorithm(com.novell.sasl.client.ParsedDirective) -> f
    void handleCipher(com.novell.sasl.client.ParsedDirective) -> g
    void handleStale(com.novell.sasl.client.ParsedDirective) -> h
    java.util.ArrayList getRealms() -> a
    java.lang.String getNonce() -> b
    int getQop() -> c
    java.lang.String getAlgorithm() -> d
com.novell.sasl.client.DigestMD5SaslClient -> com.a.a.a.b:
    java.lang.String m_authorizationId -> a
    java.lang.String m_protocol -> b
    java.lang.String m_serverName -> c
    java.util.Map m_props -> d
    org.apache.harmony.javax.security.auth.callback.CallbackHandler m_cbh -> e
    int m_state -> f
    java.lang.String m_qopValue -> g
    char[] m_HA1 -> h
    java.lang.String m_digestURI -> i
    com.novell.sasl.client.DigestChallenge m_dc -> j
    java.lang.String m_clientNonce -> k
    java.lang.String m_realm -> l
    java.lang.String m_name -> m
    org.apache.harmony.javax.security.sasl.SaslClient getClient(java.lang.String,java.lang.String,java.lang.String,java.util.Map,org.apache.harmony.javax.security.auth.callback.CallbackHandler) -> a
    boolean hasInitialResponse() -> a
    byte[] evaluateChallenge(byte[]) -> a
    char[] convertToHex(byte[]) -> b
    char[] DigestCalcHA1(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) -> a
    char[] DigestCalcResponse(char[],java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,boolean) -> a
    java.lang.String createDigestResponse(byte[]) -> d
    boolean checkServerResponseAuth(byte[]) -> c
    char getHexChar(byte) -> a
    java.lang.String getClientNonce() -> b
com.novell.sasl.client.DirectiveList -> com.a.a.a.c:
    int m_curPos -> a
    int m_errorPos -> b
    java.lang.String m_directives -> c
    int m_state -> d
    java.util.ArrayList m_directiveList -> e
    int m_scanStart -> f
    void parseDirectives() -> a
    boolean isValidTokenChar(char) -> a
    boolean isWhiteSpace(char) -> b
    void addDirective(java.lang.String,boolean) -> a
    java.util.Iterator getIterator() -> b
com.novell.sasl.client.ParsedDirective -> com.a.a.a.d:
    int m_valueType -> a
    java.lang.String m_name -> b
    java.lang.String m_value -> c
    java.lang.String getValue() -> a
    java.lang.String getName() -> b
com.novell.sasl.client.ResponseAuth -> com.a.a.a.e:
    java.lang.String m_responseValue -> a
    void checkSemantics(com.novell.sasl.client.DirectiveList) -> a
    java.lang.String getResponseValue() -> a
com.novell.sasl.client.TokenParser -> com.a.a.a.f:
    int m_curPos -> a
    int m_scanStart -> b
    int m_state -> c
    java.lang.String m_tokens -> d
    java.lang.String parseToken() -> a
    boolean isValidTokenChar(char) -> a
    boolean isWhiteSpace(char) -> b
de.measite.smack.AndroidDebugger -> a.a.a.a:
    boolean printInterpreted -> a
    org.jivesoftware.smack.Connection connection -> b
    org.jivesoftware.smack.PacketListener listener -> c
    org.jivesoftware.smack.ConnectionListener connListener -> d
    java.io.Writer writer -> e
    java.io.Reader reader -> f
    org.jivesoftware.smack.util.ReaderListener readerListener -> g
    org.jivesoftware.smack.util.WriterListener writerListener -> h
    java.io.Reader newConnectionReader(java.io.Reader) -> a
    java.io.Writer newConnectionWriter(java.io.Writer) -> a
    void userHasLogged(java.lang.String) -> a
    java.io.Reader getReader() -> a
    java.io.Writer getWriter() -> b
    org.jivesoftware.smack.PacketListener getReaderListener() -> c
    org.jivesoftware.smack.PacketListener getWriterListener() -> d
de.measite.smack.Sasl -> a.a.a.b:
    java.util.Enumeration getSaslClientFactories() -> a
    org.apache.harmony.javax.security.sasl.SaslClient createSaslClient(java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.util.Map,org.apache.harmony.javax.security.auth.callback.CallbackHandler) -> a
de.measite.smack.SaslClientFactory -> a.a.a.c:
    org.apache.harmony.javax.security.sasl.SaslClient createSaslClient(java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.util.Map,org.apache.harmony.javax.security.auth.callback.CallbackHandler) -> a
    java.lang.String[] getMechanismNames(java.util.Map) -> a
org.apache.harmony.javax.security.auth.callback.Callback -> b.a.a.a.a.a.a.a:
org.apache.harmony.javax.security.auth.callback.CallbackHandler -> b.a.a.a.a.a.a.b:
    void handle(org.apache.harmony.javax.security.auth.callback.Callback[]) -> a
org.apache.harmony.javax.security.auth.callback.ChoiceCallback -> b.a.a.a.a.a.a.c:
    int defaultChoice -> a
    java.lang.String prompt -> b
    boolean multipleSelectionsAllowed -> c
    java.lang.String[] choices -> d
    int[] selections -> e
    void setChoices(java.lang.String[]) -> a
    void setPrompt(java.lang.String) -> a
    void setDefaultChoice(int) -> a
    java.lang.String[] getChoices() -> a
    int[] getSelectedIndexes() -> b
org.apache.harmony.javax.security.auth.callback.NameCallback -> b.a.a.a.a.a.a.d:
    java.lang.String prompt -> a
    java.lang.String defaultName -> b
    java.lang.String inputName -> c
    void setPrompt(java.lang.String) -> b
    void setDefaultName(java.lang.String) -> c
    java.lang.String getDefaultName() -> a
    void setName(java.lang.String) -> a
    java.lang.String getName() -> b
org.apache.harmony.javax.security.auth.callback.PasswordCallback -> b.a.a.a.a.a.a.e:
    java.lang.String prompt -> b
    boolean echoOn -> a
    char[] inputPassword -> c
    void setPrompt(java.lang.String) -> a
    void setPassword(char[]) -> a
    char[] getPassword() -> a
    void clearPassword() -> b
org.apache.harmony.javax.security.auth.callback.TextInputCallback -> b.a.a.a.a.a.a.f:
    java.lang.String defaultText -> a
    java.lang.String prompt -> b
    java.lang.String inputText -> c
    void setPrompt(java.lang.String) -> b
    void setDefaultText(java.lang.String) -> c
    java.lang.String getText() -> a
    void setText(java.lang.String) -> a
org.apache.harmony.javax.security.auth.callback.UnsupportedCallbackException -> b.a.a.a.a.a.a.g:
    org.apache.harmony.javax.security.auth.callback.Callback callback -> a
org.apache.harmony.javax.security.sasl.RealmCallback -> b.a.a.a.a.b.a:
org.apache.harmony.javax.security.sasl.RealmChoiceCallback -> b.a.a.a.a.b.b:
org.apache.harmony.javax.security.sasl.SaslClient -> b.a.a.a.a.b.c:
    byte[] evaluateChallenge(byte[]) -> a
    boolean hasInitialResponse() -> a
org.apache.harmony.javax.security.sasl.SaslException -> b.a.a.a.a.b.d:
    java.lang.Throwable _exception -> a
    java.lang.Throwable getCause() -> getCause
    java.lang.Throwable initCause(java.lang.Throwable) -> initCause
    java.lang.String toString() -> toString
org.apache.qpid.management.common.sasl.PlainSaslClient -> b.a.b.a.a.a.a:
    boolean completed -> a
    org.apache.harmony.javax.security.auth.callback.CallbackHandler cbh -> b
    java.lang.String authorizationID -> c
    java.lang.String authenticationID -> d
    byte[] password -> e
    byte SEPARATOR -> f
    byte[] evaluateChallenge(byte[]) -> a
    boolean hasInitialResponse() -> a
    void clearPassword() -> b
    void finalize() -> finalize
    java.lang.Object[] getUserInfo() -> c
org.jivesoftware.smack.AbstractConnectionListener -> b.b.a.a:
    void connectionClosed() -> a
    void connectionClosedOnError(java.lang.Exception) -> a
    void reconnectionSuccessful() -> b
org.jivesoftware.smack.AccountManager -> b.b.a.b:
    org.jivesoftware.smack.Connection connection -> a
    org.jivesoftware.smack.packet.Registration info -> b
    boolean accountCreationSupported -> c
    void setSupportsAccountCreation(boolean) -> a
    boolean supportsAccountCreation() -> a
    java.util.Collection getAccountAttributes() -> b
    void createAccount(java.lang.String,java.lang.String) -> a
    void createAccount(java.lang.String,java.lang.String,java.util.Map) -> a
    void getRegistrationInfo() -> c
org.jivesoftware.smack.Chat -> b.b.a.c:
    org.jivesoftware.smack.ChatManager chatManager -> a
    java.lang.String threadID -> b
    java.lang.String participant -> c
    java.util.Set listeners -> d
    java.lang.String getThreadID() -> a
    java.lang.String getParticipant() -> b
    void sendMessage(java.lang.String) -> a
    void addMessageListener(org.jivesoftware.smack.MessageListener) -> a
    void deliver(org.jivesoftware.smack.packet.Message) -> a
    boolean equals(java.lang.Object) -> equals
org.jivesoftware.smack.ChatManager -> b.b.a.d:
    java.lang.String prefix -> a
    long id -> b
    java.util.Map threadChats -> c
    java.util.Map jidChats -> d
    java.util.Map baseJidChats -> e
    java.util.Set chatManagerListeners -> f
    java.util.Map interceptors -> g
    org.jivesoftware.smack.Connection connection -> h
    java.lang.String nextID() -> a
    org.jivesoftware.smack.Chat createChat(java.lang.String,org.jivesoftware.smack.MessageListener) -> a
    org.jivesoftware.smack.Chat createChat(java.lang.String,java.lang.String,org.jivesoftware.smack.MessageListener) -> a
    org.jivesoftware.smack.Chat createChat(java.lang.String,java.lang.String,boolean) -> a
    org.jivesoftware.smack.Chat createChat(org.jivesoftware.smack.packet.Message) -> a
    org.jivesoftware.smack.Chat getUserChat(java.lang.String) -> b
    org.jivesoftware.smack.Chat getThreadChat(java.lang.String) -> a
    void addChatListener(org.jivesoftware.smack.ChatManagerListener) -> a
    void deliverMessage(org.jivesoftware.smack.Chat,org.jivesoftware.smack.packet.Message) -> b
    void sendMessage(org.jivesoftware.smack.Chat,org.jivesoftware.smack.packet.Message) -> a
    org.jivesoftware.smack.Chat access$0(org.jivesoftware.smack.ChatManager,java.lang.String) -> a
    org.jivesoftware.smack.Chat access$1(org.jivesoftware.smack.ChatManager,org.jivesoftware.smack.packet.Message) -> a
    void access$2(org.jivesoftware.smack.ChatManager,org.jivesoftware.smack.Chat,org.jivesoftware.smack.packet.Message) -> a
org.jivesoftware.smack.ChatManager$1 -> b.b.a.e:
    org.jivesoftware.smack.ChatManager this$0 -> a
    boolean accept(org.jivesoftware.smack.packet.Packet) -> a
org.jivesoftware.smack.ChatManager$2 -> b.b.a.f:
    org.jivesoftware.smack.ChatManager this$0 -> a
    void processPacket(org.jivesoftware.smack.packet.Packet) -> a
org.jivesoftware.smack.ChatManagerListener -> b.b.a.g:
    void chatCreated(org.jivesoftware.smack.Chat,boolean) -> a
org.jivesoftware.smack.Connection -> b.b.a.h:
    java.util.concurrent.atomic.AtomicInteger connectionCounter -> q
    java.util.Set connectionEstablishedListeners -> r
    java.util.List compressionHandlers -> a
    boolean DEBUG_ENABLED -> b
    java.util.Collection connectionListeners -> c
    java.util.Collection collectors -> d
    java.util.Map recvListeners -> e
    java.util.Map sendListeners -> f
    java.util.Map interceptors -> g
    org.jivesoftware.smack.AccountManager accountManager -> s
    org.jivesoftware.smack.ChatManager chatManager -> h
    org.jivesoftware.smack.debugger.SmackDebugger debugger -> i
    java.io.Reader reader -> j
    java.io.Writer writer -> k
    org.jivesoftware.smack.RosterStorage rosterStorage -> l
    org.jivesoftware.smack.SASLAuthentication saslAuthentication -> m
    int connectionCounterValue -> n
    org.jivesoftware.smack.ConnectionConfiguration config -> o
    java.lang.String serviceCapsNode -> t
    org.jivesoftware.smack.compression.XMPPInputOutputStream compressionHandler -> p
    org.jivesoftware.smack.ConnectionConfiguration getConfiguration() -> a
    java.lang.String getServiceName() -> b
    java.lang.String getHost() -> c
    int getPort() -> d
    java.lang.String getUser() -> e
    java.lang.String getConnectionID() -> f
    boolean isConnected() -> g
    boolean isAuthenticated() -> h
    boolean isAnonymous() -> i
    void sendPacket(org.jivesoftware.smack.packet.Packet) -> a
    org.jivesoftware.smack.AccountManager getAccountManager() -> j
    org.jivesoftware.smack.ChatManager getChatManager() -> k
    org.jivesoftware.smack.SASLAuthentication getSASLAuthentication() -> l
    void disconnect() -> m
    void disconnect(org.jivesoftware.smack.packet.Presence) -> a
    void addConnectionCreationListener(org.jivesoftware.smack.ConnectionCreationListener) -> a
    java.util.Collection getConnectionCreationListeners() -> n
    void addConnectionListener(org.jivesoftware.smack.ConnectionListener) -> a
    java.util.Collection getConnectionListeners() -> o
    org.jivesoftware.smack.PacketCollector createPacketCollector(org.jivesoftware.smack.filter.PacketFilter) -> a
    void removePacketCollector(org.jivesoftware.smack.PacketCollector) -> a
    java.util.Collection getPacketCollectors() -> p
    void addPacketListener(org.jivesoftware.smack.PacketListener,org.jivesoftware.smack.filter.PacketFilter) -> a
    void removePacketListener(org.jivesoftware.smack.PacketListener) -> a
    void addPacketSendingListener(org.jivesoftware.smack.PacketListener,org.jivesoftware.smack.filter.PacketFilter) -> b
    void firePacketSendingListeners(org.jivesoftware.smack.packet.Packet) -> b
    void firePacketInterceptors(org.jivesoftware.smack.packet.Packet) -> c
    void initDebugger() -> q
    void setServiceCapsNode(java.lang.String) -> a
org.jivesoftware.smack.Connection$InterceptorWrapper -> b.b.a.i:
    org.jivesoftware.smack.PacketInterceptor packetInterceptor -> a
    org.jivesoftware.smack.filter.PacketFilter packetFilter -> b
    boolean equals(java.lang.Object) -> equals
    void notifyListener(org.jivesoftware.smack.packet.Packet) -> a
org.jivesoftware.smack.Connection$ListenerWrapper -> b.b.a.j:
    org.jivesoftware.smack.PacketListener packetListener -> a
    org.jivesoftware.smack.filter.PacketFilter packetFilter -> b
    void notifyListener(org.jivesoftware.smack.packet.Packet) -> a
org.jivesoftware.smack.ConnectionConfiguration -> b.b.a.k:
    java.lang.String serviceName -> c
    java.lang.String host -> d
    int port -> e
    java.util.List hostAddresses -> a
    java.lang.String truststorePath -> f
    java.lang.String truststoreType -> g
    java.lang.String truststorePassword -> h
    java.lang.String keystorePath -> i
    java.lang.String keystoreType -> j
    java.lang.String pkcs11Library -> k
    boolean verifyChainEnabled -> l
    boolean verifyRootCAEnabled -> m
    boolean selfSignedCertificateEnabled -> n
    boolean expiredCertificatesCheckEnabled -> o
    boolean notMatchingDomainCheckEnabled -> p
    boolean isRosterVersioningAvailable -> q
    javax.net.ssl.SSLContext customSSLContext -> r
    boolean compressionEnabled -> s
    boolean saslAuthenticationEnabled -> t
    org.apache.harmony.javax.security.auth.callback.CallbackHandler callbackHandler -> u
    boolean debuggerEnabled -> v
    boolean reconnectionAllowed -> w
    javax.net.SocketFactory socketFactory -> x
    java.lang.String username -> y
    java.lang.String password -> z
    java.lang.String resource -> A
    boolean sendPresence -> B
    boolean rosterLoadedAtLogin -> C
    org.jivesoftware.smack.ConnectionConfiguration$SecurityMode securityMode -> D
    org.jivesoftware.smack.proxy.ProxyInfo proxy -> b
    void init(java.lang.String,org.jivesoftware.smack.proxy.ProxyInfo) -> a
    void setServiceName(java.lang.String) -> a
    java.lang.String getServiceName() -> a
    java.lang.String getHost() -> b
    int getPort() -> c
    void setUsedHostAddress(org.jivesoftware.smack.util.dns.HostAddress) -> a
    org.jivesoftware.smack.ConnectionConfiguration$SecurityMode getSecurityMode() -> d
    java.lang.String getTruststorePath() -> e
    java.lang.String getTruststoreType() -> f
    java.lang.String getTruststorePassword() -> g
    java.lang.String getKeystorePath() -> h
    java.lang.String getKeystoreType() -> i
    java.lang.String getPKCS11Library() -> j
    boolean isVerifyChainEnabled() -> k
    boolean isVerifyRootCAEnabled() -> l
    void setVerifyRootCAEnabled(boolean) -> a
    boolean isSelfSignedCertificateEnabled() -> m
    boolean isExpiredCertificatesCheckEnabled() -> n
    boolean isNotMatchingDomainCheckEnabled() -> o
    javax.net.ssl.SSLContext getCustomSSLContext() -> p
    boolean isCompressionEnabled() -> q
    void setCompressionEnabled(boolean) -> b
    boolean isSASLAuthenticationEnabled() -> r
    boolean isDebuggerEnabled() -> s
    void setDebuggerEnabled(boolean) -> c
    void setSendPresence(boolean) -> d
    boolean isRosterLoadedAtLogin() -> t
    void setRosterLoadedAtLogin(boolean) -> e
    org.apache.harmony.javax.security.auth.callback.CallbackHandler getCallbackHandler() -> u
    javax.net.SocketFactory getSocketFactory() -> v
    java.util.List getHostAddresses() -> w
    java.lang.String getUsername() -> x
    java.lang.String getPassword() -> y
    java.lang.String getResource() -> z
    boolean isRosterVersioningAvailable() -> A
    void setRosterVersioningAvailable(boolean) -> f
    boolean isSendPresence() -> B
    void setLoginInfo(java.lang.String,java.lang.String,java.lang.String) -> a
    void initHostAddresses(java.lang.String,int) -> a
org.jivesoftware.smack.ConnectionConfiguration$SecurityMode -> b.b.a.l:
    org.jivesoftware.smack.ConnectionConfiguration$SecurityMode required -> a
    org.jivesoftware.smack.ConnectionConfiguration$SecurityMode enabled -> b
    org.jivesoftware.smack.ConnectionConfiguration$SecurityMode disabled -> c
    org.jivesoftware.smack.ConnectionConfiguration$SecurityMode[] ENUM$VALUES -> d
    org.jivesoftware.smack.ConnectionConfiguration$SecurityMode[] values() -> values
    org.jivesoftware.smack.ConnectionConfiguration$SecurityMode valueOf(java.lang.String) -> valueOf
org.jivesoftware.smack.ConnectionCreationListener -> b.b.a.m:
    void connectionCreated(org.jivesoftware.smack.Connection) -> a
org.jivesoftware.smack.ConnectionListener -> b.b.a.n:
    void connectionClosed() -> a
    void connectionClosedOnError(java.lang.Exception) -> a
    void reconnectionSuccessful() -> b
org.jivesoftware.smack.MessageListener -> b.b.a.o:
    void processMessage(org.jivesoftware.smack.Chat,org.jivesoftware.smack.packet.Message) -> a
org.jivesoftware.smack.NonSASLAuthentication -> b.b.a.p:
    org.jivesoftware.smack.Connection connection -> a
    java.lang.String authenticate(java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String authenticateAnonymously() -> a
org.jivesoftware.smack.PacketCollector -> b.b.a.q:
    org.jivesoftware.smack.filter.PacketFilter packetFilter -> a
    java.util.concurrent.ArrayBlockingQueue resultQueue -> b
    org.jivesoftware.smack.Connection connection -> c
    boolean cancelled -> d
    void cancel() -> a
    org.jivesoftware.smack.packet.Packet nextResult(long) -> a
    void processPacket(org.jivesoftware.smack.packet.Packet) -> a
org.jivesoftware.smack.PacketInterceptor -> b.b.a.r:
    void interceptPacket(org.jivesoftware.smack.packet.Packet) -> a
org.jivesoftware.smack.PacketListener -> b.b.a.s:
    void processPacket(org.jivesoftware.smack.packet.Packet) -> a
org.jivesoftware.smack.PacketReader -> b.b.a.t:
    java.lang.Thread readerThread -> b
    java.util.concurrent.ExecutorService listenerExecutor -> c
    org.jivesoftware.smack.XMPPConnection connection -> d
    org.xmlpull.v1.XmlPullParser parser -> e
    boolean done -> a
    java.lang.String connectionID -> f
    void init() -> a
    void startup() -> b
    void shutdown() -> c
    void cleanup() -> d
    void resetParser() -> e
    void parsePackets(java.lang.Thread) -> a
    void releaseConnectionIDLock() -> f
    void processPacket(org.jivesoftware.smack.packet.Packet) -> a
    void parseFeatures(org.xmlpull.v1.XmlPullParser) -> a
    org.jivesoftware.smack.XMPPConnection access$0(org.jivesoftware.smack.PacketReader) -> a
    void access$1(org.jivesoftware.smack.PacketReader,java.lang.Thread) -> a
org.jivesoftware.smack.PacketReader$1 -> b.b.a.u:
    org.jivesoftware.smack.PacketReader this$0 -> a
    void run() -> run
org.jivesoftware.smack.PacketReader$2 -> b.b.a.v:
    org.jivesoftware.smack.PacketReader this$0 -> a
    java.lang.Thread newThread(java.lang.Runnable) -> newThread
org.jivesoftware.smack.PacketReader$ListenerNotification -> b.b.a.w:
    org.jivesoftware.smack.packet.Packet packet -> b
    org.jivesoftware.smack.PacketReader this$0 -> a
    void run() -> run
org.jivesoftware.smack.PacketWriter -> b.b.a.x:
    java.lang.Thread writerThread -> b
    java.lang.Thread keepAliveThread -> c
    java.io.Writer writer -> d
    org.jivesoftware.smack.XMPPConnection connection -> e
    java.util.concurrent.BlockingQueue queue -> f
    boolean done -> a
    void init() -> a
    void sendPacket(org.jivesoftware.smack.packet.Packet) -> a
    void startup() -> b
    void setWriter(java.io.Writer) -> a
    void shutdown() -> c
    void cleanup() -> d
    org.jivesoftware.smack.packet.Packet nextPacket() -> f
    void writePackets(java.lang.Thread) -> a
    void openStream() -> e
    void access$0(org.jivesoftware.smack.PacketWriter,java.lang.Thread) -> a
org.jivesoftware.smack.PacketWriter$1 -> b.b.a.y:
    org.jivesoftware.smack.PacketWriter this$0 -> a
    void run() -> run
org.jivesoftware.smack.Roster -> b.b.a.z:
    org.jivesoftware.smack.Roster$SubscriptionMode defaultSubscriptionMode -> b
    org.jivesoftware.smack.RosterStorage persistentStorage -> c
    org.jivesoftware.smack.Connection connection -> d
    java.util.Map groups -> e
    java.util.Map entries -> f
    java.util.List unfiledEntries -> g
    java.util.List rosterListeners -> h
    java.util.Map presenceMap -> i
    boolean rosterInitialized -> a
    org.jivesoftware.smack.Roster$PresencePacketListener presencePacketListener -> j
    org.jivesoftware.smack.Roster$SubscriptionMode subscriptionMode -> k
    java.lang.String requestPacketId -> l
    org.jivesoftware.smack.Roster$SubscriptionMode getDefaultSubscriptionMode() -> a
    void reload() -> b
    org.jivesoftware.smack.RosterGroup createGroup(java.lang.String) -> a
    void insertRosterItem(org.jivesoftware.smack.packet.RosterPacket$Item,java.util.Collection,java.util.Collection,java.util.Collection) -> a
    org.jivesoftware.smack.RosterEntry getEntry(java.lang.String) -> b
    boolean contains(java.lang.String) -> c
    org.jivesoftware.smack.RosterGroup getGroup(java.lang.String) -> d
    java.util.Collection getGroups() -> c
    void cleanup() -> d
    java.lang.String getPresenceMapKey(java.lang.String) -> e
    void setOfflinePresences() -> e
    void fireRosterChangedEvent(java.util.Collection,java.util.Collection,java.util.Collection) -> a
    void fireRosterPresenceEvent(org.jivesoftware.smack.packet.Presence) -> a
    java.lang.String access$0(org.jivesoftware.smack.Roster,java.lang.String) -> a
    java.util.Map access$1(org.jivesoftware.smack.Roster) -> a
    java.util.Map access$2(org.jivesoftware.smack.Roster) -> b
    void access$3(org.jivesoftware.smack.Roster,org.jivesoftware.smack.packet.Presence) -> a
    org.jivesoftware.smack.Roster$SubscriptionMode access$4(org.jivesoftware.smack.Roster) -> c
    org.jivesoftware.smack.Connection access$5(org.jivesoftware.smack.Roster) -> d
    org.jivesoftware.smack.RosterStorage access$6(org.jivesoftware.smack.Roster) -> e
    void access$7(org.jivesoftware.smack.Roster,org.jivesoftware.smack.packet.RosterPacket$Item,java.util.Collection,java.util.Collection,java.util.Collection) -> a
    void access$8(org.jivesoftware.smack.Roster,java.util.Collection,java.util.Collection,java.util.Collection) -> a
    void access$9(org.jivesoftware.smack.Roster,org.jivesoftware.smack.RosterStorage) -> a
    void access$10(org.jivesoftware.smack.Roster) -> f
org.jivesoftware.smack.Roster$1 -> b.b.a.aa:
    org.jivesoftware.smack.Roster this$0 -> a
    void connectionClosed() -> a
    void connectionClosedOnError(java.lang.Exception) -> a
org.jivesoftware.smack.Roster$2 -> b.b.a.ab:
    org.jivesoftware.smack.Roster this$0 -> a
    org.jivesoftware.smack.ConnectionListener val$connectionListener -> b
    void connectionCreated(org.jivesoftware.smack.Connection) -> a
org.jivesoftware.smack.Roster$PresencePacketListener -> b.b.a.ac:
    org.jivesoftware.smack.Roster this$0 -> a
    void processPacket(org.jivesoftware.smack.packet.Packet) -> a
org.jivesoftware.smack.Roster$RosterPacketListener -> b.b.a.ad:
    org.jivesoftware.smack.Roster this$0 -> a
    void processPacket(org.jivesoftware.smack.packet.Packet) -> a
org.jivesoftware.smack.Roster$RosterResultListener -> b.b.a.ae:
    org.jivesoftware.smack.Roster this$0 -> a
    void processPacket(org.jivesoftware.smack.packet.Packet) -> a
org.jivesoftware.smack.Roster$SubscriptionMode -> b.b.a.af:
    org.jivesoftware.smack.Roster$SubscriptionMode accept_all -> a
    org.jivesoftware.smack.Roster$SubscriptionMode reject_all -> b
    org.jivesoftware.smack.Roster$SubscriptionMode manual -> c
    org.jivesoftware.smack.Roster$SubscriptionMode[] ENUM$VALUES -> d
    org.jivesoftware.smack.Roster$SubscriptionMode[] values() -> values
    org.jivesoftware.smack.Roster$SubscriptionMode valueOf(java.lang.String) -> valueOf
org.jivesoftware.smack.RosterEntry -> b.b.a.ag:
    java.lang.String user -> a
    java.lang.String name -> b
    org.jivesoftware.smack.packet.RosterPacket$ItemType type -> c
    org.jivesoftware.smack.packet.RosterPacket$ItemStatus status -> d
    org.jivesoftware.smack.Roster roster -> e
    org.jivesoftware.smack.Connection connection -> f
    java.lang.String getUser() -> a
    java.util.Collection getGroups() -> b
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
org.jivesoftware.smack.RosterGroup -> b.b.a.ah:
    java.lang.String name -> a
    org.jivesoftware.smack.Connection connection -> b
    java.util.List entries -> c
    java.lang.String getName() -> a
    int getEntryCount() -> b
    boolean contains(org.jivesoftware.smack.RosterEntry) -> a
    void addEntryLocal(org.jivesoftware.smack.RosterEntry) -> b
    void removeEntryLocal(org.jivesoftware.smack.RosterEntry) -> c
org.jivesoftware.smack.RosterListener -> b.b.a.ai:
    void entriesAdded(java.util.Collection) -> a
    void entriesUpdated(java.util.Collection) -> b
    void entriesDeleted(java.util.Collection) -> c
    void presenceChanged(org.jivesoftware.smack.packet.Presence) -> a
org.jivesoftware.smack.RosterStorage -> b.b.a.aj:
    java.util.List getEntries() -> a
    java.lang.String getRosterVersion() -> b
    void addEntry(org.jivesoftware.smack.packet.RosterPacket$Item,java.lang.String) -> a
    void removeEntry(java.lang.String) -> a
org.jivesoftware.smack.SASLAuthentication -> b.b.a.ak:
    java.util.Map implementedMechanisms -> a
    java.util.List mechanismsPreferences -> b
    org.jivesoftware.smack.Connection connection -> c
    java.util.Collection serverMechanisms -> d
    org.jivesoftware.smack.sasl.SASLMechanism currentMechanism -> e
    boolean saslNegotiated -> f
    boolean saslFailed -> g
    boolean resourceBinded -> h
    boolean sessionSupported -> i
    java.lang.String errorCondition -> j
    void registerSASLMechanism(java.lang.String,java.lang.Class) -> a
    void supportSASLMechanism(java.lang.String,int) -> a
    boolean hasAnonymousAuthentication() -> a
    boolean hasNonAnonymousAuthentication() -> b
    java.lang.String authenticate(java.lang.String,java.lang.String,org.apache.harmony.javax.security.auth.callback.CallbackHandler) -> a
    java.lang.String authenticate(java.lang.String,java.lang.String,java.lang.String) -> a
    java.lang.String authenticateAnonymously() -> c
    java.lang.String bindResourceAndEstablishSession(java.lang.String) -> c
    void setAvailableSASLMethods(java.util.Collection) -> a
    void challengeReceived(java.lang.String) -> a
    void authenticated() -> d
    void authenticationFailed() -> e
    void authenticationFailed(java.lang.String) -> b
    void bindingRequired() -> f
    void send(org.jivesoftware.smack.packet.Packet) -> a
    void sessionsSupported() -> g
    void init() -> h
org.jivesoftware.smack.ServerTrustManager -> b.b.a.al:
    java.util.regex.Pattern cnPattern -> a
    org.jivesoftware.smack.ConnectionConfiguration configuration -> b
    java.lang.String server -> c
    java.security.KeyStore trustStore -> d
    java.util.Map stores -> e
    java.security.cert.X509Certificate[] getAcceptedIssuers() -> getAcceptedIssuers
    void checkClientTrusted(java.security.cert.X509Certificate[],java.lang.String) -> checkClientTrusted
    void checkServerTrusted(java.security.cert.X509Certificate[],java.lang.String) -> checkServerTrusted
    java.util.List getPeerIdentity(java.security.cert.X509Certificate) -> a
    java.util.List getSubjectAlternativeNames(java.security.cert.X509Certificate) -> b
org.jivesoftware.smack.ServerTrustManager$KeyStoreOptions -> b.b.a.am:
    java.lang.String type -> a
    java.lang.String path -> b
    java.lang.String password -> c
    java.lang.String getType() -> a
    java.lang.String getPath() -> b
    java.lang.String getPassword() -> c
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
org.jivesoftware.smack.SmackConfiguration -> b.b.a.an:
    int packetReplyTimeout -> a
    java.util.Vector defaultMechs -> b
    boolean localSocks5ProxyEnabled -> c
    int localSocks5ProxyPort -> d
    int packetCollectorSize -> e
    int defaultPingInterval -> f
    boolean autoEnableEntityCaps -> g
    java.lang.String getVersion() -> a
    int getPacketReplyTimeout() -> b
    int getPacketCollectorSize() -> c
    void parseClassToLoad(org.xmlpull.v1.XmlPullParser) -> a
    int parseIntProperty(org.xmlpull.v1.XmlPullParser,int) -> a
    java.lang.ClassLoader[] getClassLoaders() -> d
org.jivesoftware.smack.XMPPConnection -> b.b.a.ao:
    java.net.Socket socket -> q
    java.lang.String connectionID -> r
    java.lang.String user -> v
    boolean connected -> w
    boolean socketClosed -> x
    boolean authenticated -> y
    boolean wasAuthenticated -> z
    boolean anonymous -> A
    boolean usingTLS -> B
    org.jivesoftware.smack.PacketWriter packetWriter -> s
    org.jivesoftware.smack.PacketReader packetReader -> t
    org.jivesoftware.smack.Roster roster -> u
    java.util.Collection compressionMethods -> C
    boolean serverAckdCompression -> D
    java.lang.String getConnectionID() -> f
    java.lang.String getUser() -> e
    void login(java.lang.String,java.lang.String,java.lang.String) -> a
    void loginAnonymously() -> r
    boolean isConnected() -> g
    boolean isSecureConnection() -> s
    boolean isSocketClosed() -> t
    boolean isAuthenticated() -> h
    boolean isAnonymous() -> i
    void shutdown(org.jivesoftware.smack.packet.Presence) -> b
    void disconnect(org.jivesoftware.smack.packet.Presence) -> a
    void sendPacket(org.jivesoftware.smack.packet.Packet) -> a
    void connectUsingConfiguration(org.jivesoftware.smack.ConnectionConfiguration) -> a
    void initConnection() -> B
    void initReaderAndWriter() -> C
    boolean isUsingTLS() -> u
    void startTLSReceived(boolean) -> a
    void proceedTLSReceived() -> v
    void setAvailableCompressionMethods(java.util.Collection) -> a
    org.jivesoftware.smack.compression.XMPPInputOutputStream maybeGetCompressionHandler() -> D
    boolean isUsingCompression() -> w
    boolean useCompression() -> E
    void requestStreamCompression(java.lang.String) -> b
    void startStreamCompression() -> x
    void streamCompressionDenied() -> y
    void connect() -> z
    void setWasAuthenticated(boolean) -> b
    void notifyConnectionError(java.lang.Exception) -> a
    void notifyReconnection() -> A
org.jivesoftware.smack.XMPPException -> b.b.a.ap:
    org.jivesoftware.smack.packet.StreamError streamError -> a
    org.jivesoftware.smack.packet.XMPPError error -> b
    java.lang.Throwable wrappedThrowable -> c
    void printStackTrace() -> printStackTrace
    void printStackTrace(java.io.PrintStream) -> printStackTrace
    void printStackTrace(java.io.PrintWriter) -> printStackTrace
    java.lang.String getMessage() -> getMessage
    java.lang.String toString() -> toString
org.jivesoftware.smack.compression.Java7ZlibInputOutputStream -> b.b.a.a.a:
    java.lang.reflect.Method method -> b
    boolean supported -> c
    boolean isSupported() -> a
    java.io.InputStream getInputStream(java.io.InputStream) -> a
    java.io.OutputStream getOutputStream(java.io.OutputStream) -> a
    boolean access$0() -> b
    java.lang.reflect.Method access$1() -> c
org.jivesoftware.smack.compression.Java7ZlibInputOutputStream$1 -> b.b.a.a.b:
    org.jivesoftware.smack.compression.Java7ZlibInputOutputStream this$0 -> a
    int available() -> available
org.jivesoftware.smack.compression.Java7ZlibInputOutputStream$2 -> b.b.a.a.c:
    org.jivesoftware.smack.compression.Java7ZlibInputOutputStream this$0 -> a
    void flush() -> flush
org.jivesoftware.smack.compression.JzlibInputOutputStream -> b.b.a.a.d:
    java.lang.Class zoClass -> b
    java.lang.Class ziClass -> c
    boolean isSupported() -> a
    java.io.InputStream getInputStream(java.io.InputStream) -> a
    java.io.OutputStream getOutputStream(java.io.OutputStream) -> a
org.jivesoftware.smack.compression.XMPPInputOutputStream -> b.b.a.a.e:
    java.lang.String compressionMethod -> a
    java.lang.String getCompressionMethod() -> d
    boolean isSupported() -> a
    java.io.InputStream getInputStream(java.io.InputStream) -> a
    java.io.OutputStream getOutputStream(java.io.OutputStream) -> a
org.jivesoftware.smack.debugger.ConsoleDebugger -> b.b.a.b.a:
    boolean printInterpreted -> a
    org.jivesoftware.smack.Connection connection -> b
    org.jivesoftware.smack.PacketListener listener -> c
    org.jivesoftware.smack.ConnectionListener connListener -> d
    java.io.Writer writer -> e
    java.io.Reader reader -> f
    org.jivesoftware.smack.util.ReaderListener readerListener -> g
    org.jivesoftware.smack.util.WriterListener writerListener -> h
    java.io.Reader newConnectionReader(java.io.Reader) -> a
    java.io.Writer newConnectionWriter(java.io.Writer) -> a
    void userHasLogged(java.lang.String) -> a
    java.io.Reader getReader() -> a
    java.io.Writer getWriter() -> b
    org.jivesoftware.smack.PacketListener getReaderListener() -> c
    org.jivesoftware.smack.PacketListener getWriterListener() -> d
org.jivesoftware.smack.debugger.SmackDebugger -> b.b.a.b.b:
    void userHasLogged(java.lang.String) -> a
    java.io.Reader getReader() -> a
    java.io.Writer getWriter() -> b
    java.io.Reader newConnectionReader(java.io.Reader) -> a
    java.io.Writer newConnectionWriter(java.io.Writer) -> a
    org.jivesoftware.smack.PacketListener getReaderListener() -> c
    org.jivesoftware.smack.PacketListener getWriterListener() -> d
org.jivesoftware.smack.filter.AndFilter -> b.b.a.c.a:
    java.util.List filters -> a
    boolean accept(org.jivesoftware.smack.packet.Packet) -> a
    java.lang.String toString() -> toString
org.jivesoftware.smack.filter.PacketFilter -> b.b.a.c.b:
    boolean accept(org.jivesoftware.smack.packet.Packet) -> a
org.jivesoftware.smack.filter.PacketIDFilter -> b.b.a.c.c:
    java.lang.String packetID -> a
    boolean accept(org.jivesoftware.smack.packet.Packet) -> a
    java.lang.String toString() -> toString
org.jivesoftware.smack.filter.PacketTypeFilter -> b.b.a.c.d:
    java.lang.Class packetType -> a
    boolean accept(org.jivesoftware.smack.packet.Packet) -> a
    java.lang.String toString() -> toString
org.jivesoftware.smack.packet.Authentication -> b.b.a.d.a:
    java.lang.String username -> c
    java.lang.String password -> d
    java.lang.String digest -> e
    java.lang.String resource -> f
    void setUsername(java.lang.String) -> a
    java.lang.String getPassword() -> a
    void setPassword(java.lang.String) -> b
    java.lang.String getDigest() -> b
    void setDigest(java.lang.String,java.lang.String) -> a
    void setDigest(java.lang.String) -> c
    java.lang.String getResource() -> c
    void setResource(java.lang.String) -> d
    java.lang.String getChildElementXML() -> d
org.jivesoftware.smack.packet.Bind -> b.b.a.d.b:
    java.lang.String resource -> c
    java.lang.String jid -> d
    void setResource(java.lang.String) -> a
    java.lang.String getJid() -> a
    void setJid(java.lang.String) -> b
    java.lang.String getChildElementXML() -> d
org.jivesoftware.smack.packet.DefaultPacketExtension -> b.b.a.d.c:
    java.lang.String elementName -> a
    java.lang.String namespace -> b
    java.util.Map map -> c
    java.lang.String getElementName() -> a
    java.lang.String toXML() -> b
    java.util.Collection getNames() -> c
    java.lang.String getValue(java.lang.String) -> a
    void setValue(java.lang.String,java.lang.String) -> a
org.jivesoftware.smack.packet.IQ -> b.b.a.d.d:
    org.jivesoftware.smack.packet.IQ$Type type -> c
    org.jivesoftware.smack.packet.IQ$Type getType() -> e
    void setType(org.jivesoftware.smack.packet.IQ$Type) -> a
    java.lang.String toXML() -> f
    java.lang.String getChildElementXML() -> d
org.jivesoftware.smack.packet.IQ$Type -> b.b.a.d.e:
    org.jivesoftware.smack.packet.IQ$Type GET -> a
    org.jivesoftware.smack.packet.IQ$Type SET -> b
    org.jivesoftware.smack.packet.IQ$Type RESULT -> c
    org.jivesoftware.smack.packet.IQ$Type ERROR -> d
    java.lang.String value -> e
    org.jivesoftware.smack.packet.IQ$Type fromString(java.lang.String) -> a
    java.lang.String toString() -> toString
org.jivesoftware.smack.packet.Message -> b.b.a.d.f:
    org.jivesoftware.smack.packet.Message$Type type -> c
    java.lang.String thread -> d
    java.lang.String language -> e
    java.util.Set subjects -> f
    java.util.Set bodies -> g
    org.jivesoftware.smack.packet.Message$Type getType() -> a
    void setType(org.jivesoftware.smack.packet.Message$Type) -> a
    java.lang.String getSubject(java.lang.String) -> a
    org.jivesoftware.smack.packet.Message$Subject getMessageSubject(java.lang.String) -> k
    java.util.Collection getSubjects() -> b
    org.jivesoftware.smack.packet.Message$Subject addSubject(java.lang.String,java.lang.String) -> a
    java.lang.String getBody() -> c
    java.lang.String getBody(java.lang.String) -> b
    org.jivesoftware.smack.packet.Message$Body getMessageBody(java.lang.String) -> l
    java.util.Collection getBodies() -> d
    void setBody(java.lang.String) -> c
    org.jivesoftware.smack.packet.Message$Body addBody(java.lang.String,java.lang.String) -> b
    boolean removeBody(java.lang.String) -> d
    java.lang.String getThread() -> e
    void setThread(java.lang.String) -> e
    java.lang.String getLanguage() -> g
    void setLanguage(java.lang.String) -> f
    java.lang.String determineLanguage(java.lang.String) -> m
    java.lang.String toXML() -> f
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.jivesoftware.smack.packet.Message$Body -> b.b.a.d.g:
    java.lang.String message -> a
    java.lang.String language -> b
    java.lang.String getLanguage() -> a
    java.lang.String getMessage() -> b
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String access$0(org.jivesoftware.smack.packet.Message$Body) -> a
    java.lang.String access$1(org.jivesoftware.smack.packet.Message$Body) -> b
org.jivesoftware.smack.packet.Message$Subject -> b.b.a.d.h:
    java.lang.String subject -> a
    java.lang.String language -> b
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    java.lang.String access$0(org.jivesoftware.smack.packet.Message$Subject) -> a
    java.lang.String access$1(org.jivesoftware.smack.packet.Message$Subject) -> b
org.jivesoftware.smack.packet.Message$Type -> b.b.a.d.i:
    org.jivesoftware.smack.packet.Message$Type normal -> a
    org.jivesoftware.smack.packet.Message$Type chat -> b
    org.jivesoftware.smack.packet.Message$Type groupchat -> c
    org.jivesoftware.smack.packet.Message$Type headline -> d
    org.jivesoftware.smack.packet.Message$Type error -> e
    org.jivesoftware.smack.packet.Message$Type[] ENUM$VALUES -> f
    org.jivesoftware.smack.packet.Message$Type fromString(java.lang.String) -> a
    org.jivesoftware.smack.packet.Message$Type[] values() -> values
    org.jivesoftware.smack.packet.Message$Type valueOf(java.lang.String) -> valueOf
org.jivesoftware.smack.packet.Packet -> b.b.a.d.j:
    java.lang.String DEFAULT_LANGUAGE -> a
    java.lang.String DEFAULT_XML_NS -> c
    java.text.DateFormat XEP_0082_UTC_FORMAT -> b
    java.lang.String prefix -> d
    long id -> e
    java.lang.String xmlns -> f
    java.lang.String packetID -> g
    java.lang.String to -> h
    java.lang.String from -> i
    java.util.List packetExtensions -> j
    java.util.Map properties -> k
    org.jivesoftware.smack.packet.XMPPError error -> l
    java.lang.String nextID() -> h
    java.lang.String getPacketID() -> i
    void setPacketID(java.lang.String) -> g
    java.lang.String getTo() -> j
    void setTo(java.lang.String) -> h
    java.lang.String getFrom() -> k
    void setFrom(java.lang.String) -> i
    org.jivesoftware.smack.packet.XMPPError getError() -> l
    void setError(org.jivesoftware.smack.packet.XMPPError) -> a
    java.util.Collection getExtensions() -> m
    void addExtension(org.jivesoftware.smack.packet.PacketExtension) -> a
    java.lang.Object getProperty(java.lang.String) -> j
    void setProperty(java.lang.String,java.lang.Object) -> a
    java.util.Collection getPropertyNames() -> n
    java.lang.String toXML() -> f
    java.lang.String getExtensionsXML() -> o
    java.lang.String getXmlns() -> p
    java.lang.String getDefaultLanguage() -> q
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.jivesoftware.smack.packet.PacketExtension -> b.b.a.d.k:
    java.lang.String getElementName() -> a
    java.lang.String toXML() -> b
org.jivesoftware.smack.packet.Presence -> b.b.a.d.l:
    org.jivesoftware.smack.packet.Presence$Type type -> c
    java.lang.String status -> d
    int priority -> e
    org.jivesoftware.smack.packet.Presence$Mode mode -> f
    java.lang.String language -> g
    org.jivesoftware.smack.packet.Presence$Type getType() -> a
    void setType(org.jivesoftware.smack.packet.Presence$Type) -> a
    java.lang.String getStatus() -> b
    void setStatus(java.lang.String) -> a
    void setPriority(int) -> a
    void setMode(org.jivesoftware.smack.packet.Presence$Mode) -> a
    java.lang.String getLanguage() -> c
    void setLanguage(java.lang.String) -> b
    java.lang.String toXML() -> f
    java.lang.String toString() -> toString
org.jivesoftware.smack.packet.Presence$Mode -> b.b.a.d.m:
    org.jivesoftware.smack.packet.Presence$Mode chat -> a
    org.jivesoftware.smack.packet.Presence$Mode available -> b
    org.jivesoftware.smack.packet.Presence$Mode away -> c
    org.jivesoftware.smack.packet.Presence$Mode xa -> d
    org.jivesoftware.smack.packet.Presence$Mode dnd -> e
    org.jivesoftware.smack.packet.Presence$Mode[] ENUM$VALUES -> f
    org.jivesoftware.smack.packet.Presence$Mode[] values() -> values
    org.jivesoftware.smack.packet.Presence$Mode valueOf(java.lang.String) -> valueOf
org.jivesoftware.smack.packet.Presence$Type -> b.b.a.d.n:
    org.jivesoftware.smack.packet.Presence$Type available -> a
    org.jivesoftware.smack.packet.Presence$Type unavailable -> b
    org.jivesoftware.smack.packet.Presence$Type subscribe -> c
    org.jivesoftware.smack.packet.Presence$Type subscribed -> d
    org.jivesoftware.smack.packet.Presence$Type unsubscribe -> e
    org.jivesoftware.smack.packet.Presence$Type unsubscribed -> f
    org.jivesoftware.smack.packet.Presence$Type error -> g
    org.jivesoftware.smack.packet.Presence$Type[] ENUM$VALUES -> h
    org.jivesoftware.smack.packet.Presence$Type[] values() -> values
    org.jivesoftware.smack.packet.Presence$Type valueOf(java.lang.String) -> valueOf
org.jivesoftware.smack.packet.Registration -> b.b.a.d.o:
    java.lang.String instructions -> c
    java.util.Map attributes -> d
    java.util.List requiredFields -> e
    boolean registered -> f
    boolean remove -> g
    void setInstructions(java.lang.String) -> a
    java.util.Map getAttributes() -> a
    void setAttributes(java.util.Map) -> a
    java.lang.String getChildElementXML() -> d
org.jivesoftware.smack.packet.RosterPacket -> b.b.a.d.p:
    java.util.List rosterItems -> c
    java.lang.String version -> d
    void addRosterItem(org.jivesoftware.smack.packet.RosterPacket$Item) -> a
    java.lang.String getVersion() -> a
    void setVersion(java.lang.String) -> a
    java.util.Collection getRosterItems() -> b
    java.lang.String getChildElementXML() -> d
org.jivesoftware.smack.packet.RosterPacket$Item -> b.b.a.d.q:
    java.lang.String user -> a
    java.lang.String name -> b
    org.jivesoftware.smack.packet.RosterPacket$ItemType itemType -> c
    org.jivesoftware.smack.packet.RosterPacket$ItemStatus itemStatus -> d
    java.util.Set groupNames -> e
    java.lang.String getUser() -> a
    java.lang.String getName() -> b
    org.jivesoftware.smack.packet.RosterPacket$ItemType getItemType() -> c
    void setItemType(org.jivesoftware.smack.packet.RosterPacket$ItemType) -> a
    org.jivesoftware.smack.packet.RosterPacket$ItemStatus getItemStatus() -> d
    void setItemStatus(org.jivesoftware.smack.packet.RosterPacket$ItemStatus) -> a
    java.util.Set getGroupNames() -> e
    void addGroupName(java.lang.String) -> a
    java.lang.String toXML() -> f
org.jivesoftware.smack.packet.RosterPacket$ItemStatus -> b.b.a.d.r:
    org.jivesoftware.smack.packet.RosterPacket$ItemStatus SUBSCRIPTION_PENDING -> a
    org.jivesoftware.smack.packet.RosterPacket$ItemStatus UNSUBSCRIPTION_PENDING -> b
    java.lang.String value -> c
    org.jivesoftware.smack.packet.RosterPacket$ItemStatus fromString(java.lang.String) -> a
    java.lang.String toString() -> toString
org.jivesoftware.smack.packet.RosterPacket$ItemType -> b.b.a.d.s:
    org.jivesoftware.smack.packet.RosterPacket$ItemType none -> a
    org.jivesoftware.smack.packet.RosterPacket$ItemType to -> b
    org.jivesoftware.smack.packet.RosterPacket$ItemType from -> c
    org.jivesoftware.smack.packet.RosterPacket$ItemType both -> d
    org.jivesoftware.smack.packet.RosterPacket$ItemType remove -> e
    org.jivesoftware.smack.packet.RosterPacket$ItemType[] ENUM$VALUES -> f
    org.jivesoftware.smack.packet.RosterPacket$ItemType[] values() -> values
    org.jivesoftware.smack.packet.RosterPacket$ItemType valueOf(java.lang.String) -> valueOf
org.jivesoftware.smack.packet.Session -> b.b.a.d.t:
    java.lang.String getChildElementXML() -> d
org.jivesoftware.smack.packet.StreamError -> b.b.a.d.u:
    java.lang.String code -> a
    java.lang.String toString() -> toString
org.jivesoftware.smack.packet.XMPPError -> b.b.a.d.v:
    int code -> a
    org.jivesoftware.smack.packet.XMPPError$Type type -> b
    java.lang.String condition -> c
    java.lang.String message -> d
    java.util.List applicationExtensions -> e
    void init(org.jivesoftware.smack.packet.XMPPError$Condition) -> a
    java.lang.String toXML() -> a
    java.lang.String toString() -> toString
    java.util.List getExtensions() -> b
org.jivesoftware.smack.packet.XMPPError$Condition -> b.b.a.d.w:
    org.jivesoftware.smack.packet.XMPPError$Condition interna_server_error -> a
    org.jivesoftware.smack.packet.XMPPError$Condition forbidden -> b
    org.jivesoftware.smack.packet.XMPPError$Condition bad_request -> c
    org.jivesoftware.smack.packet.XMPPError$Condition conflict -> d
    org.jivesoftware.smack.packet.XMPPError$Condition feature_not_implemented -> e
    org.jivesoftware.smack.packet.XMPPError$Condition gone -> f
    org.jivesoftware.smack.packet.XMPPError$Condition item_not_found -> g
    org.jivesoftware.smack.packet.XMPPError$Condition jid_malformed -> h
    org.jivesoftware.smack.packet.XMPPError$Condition no_acceptable -> i
    org.jivesoftware.smack.packet.XMPPError$Condition not_allowed -> j
    org.jivesoftware.smack.packet.XMPPError$Condition not_authorized -> k
    org.jivesoftware.smack.packet.XMPPError$Condition payment_required -> l
    org.jivesoftware.smack.packet.XMPPError$Condition recipient_unavailable -> m
    org.jivesoftware.smack.packet.XMPPError$Condition redirect -> n
    org.jivesoftware.smack.packet.XMPPError$Condition registration_required -> o
    org.jivesoftware.smack.packet.XMPPError$Condition remote_server_error -> p
    org.jivesoftware.smack.packet.XMPPError$Condition remote_server_not_found -> q
    org.jivesoftware.smack.packet.XMPPError$Condition remote_server_timeout -> r
    org.jivesoftware.smack.packet.XMPPError$Condition resource_constraint -> s
    org.jivesoftware.smack.packet.XMPPError$Condition service_unavailable -> t
    org.jivesoftware.smack.packet.XMPPError$Condition subscription_required -> u
    org.jivesoftware.smack.packet.XMPPError$Condition undefined_condition -> v
    org.jivesoftware.smack.packet.XMPPError$Condition unexpected_request -> w
    org.jivesoftware.smack.packet.XMPPError$Condition request_timeout -> x
    java.lang.String value -> y
    java.lang.String toString() -> toString
    java.lang.String access$0(org.jivesoftware.smack.packet.XMPPError$Condition) -> a
org.jivesoftware.smack.packet.XMPPError$ErrorSpecification -> b.b.a.d.x:
    int code -> a
    org.jivesoftware.smack.packet.XMPPError$Type type -> b
    org.jivesoftware.smack.packet.XMPPError$Condition condition -> c
    java.util.Map instances -> d
    java.util.Map errorSpecifications() -> c
    org.jivesoftware.smack.packet.XMPPError$ErrorSpecification specFor(org.jivesoftware.smack.packet.XMPPError$Condition) -> a
    org.jivesoftware.smack.packet.XMPPError$Type getType() -> a
    int getCode() -> b
org.jivesoftware.smack.packet.XMPPError$Type -> b.b.a.d.y:
    org.jivesoftware.smack.packet.XMPPError$Type WAIT -> a
    org.jivesoftware.smack.packet.XMPPError$Type CANCEL -> b
    org.jivesoftware.smack.packet.XMPPError$Type MODIFY -> c
    org.jivesoftware.smack.packet.XMPPError$Type AUTH -> d
    org.jivesoftware.smack.packet.XMPPError$Type CONTINUE -> e
    org.jivesoftware.smack.packet.XMPPError$Type[] ENUM$VALUES -> f
    org.jivesoftware.smack.packet.XMPPError$Type[] values() -> values
    org.jivesoftware.smack.packet.XMPPError$Type valueOf(java.lang.String) -> valueOf
org.jivesoftware.smack.provider.IQProvider -> b.b.a.e.a:
    org.jivesoftware.smack.packet.IQ parseIQ(org.xmlpull.v1.XmlPullParser) -> a
org.jivesoftware.smack.provider.PacketExtensionProvider -> b.b.a.e.b:
    org.jivesoftware.smack.packet.PacketExtension parseExtension(org.xmlpull.v1.XmlPullParser) -> a
org.jivesoftware.smack.provider.ProviderManager -> b.b.a.e.c:
    org.jivesoftware.smack.provider.ProviderManager instance -> a
    java.util.Map extensionProviders -> b
    java.util.Map iqProviders -> c
    org.jivesoftware.smack.provider.ProviderManager getInstance() -> a
    void initialize() -> b
    java.lang.Object getIQProvider(java.lang.String,java.lang.String) -> a
    void addIQProvider(java.lang.String,java.lang.String,java.lang.Object) -> a
    java.lang.Object getExtensionProvider(java.lang.String,java.lang.String) -> b
    void addExtensionProvider(java.lang.String,java.lang.String,java.lang.Object) -> b
    java.lang.String getProviderKey(java.lang.String,java.lang.String) -> c
    java.lang.ClassLoader[] getClassLoaders() -> c
org.jivesoftware.smack.proxy.DirectSocketFactory -> b.b.a.f.a:
    int roundrobin -> a
    java.net.Socket createSocket(java.lang.String,int) -> createSocket
    java.net.Socket createSocket(java.lang.String,int,java.net.InetAddress,int) -> createSocket
    java.net.Socket createSocket(java.net.InetAddress,int) -> createSocket
    java.net.Socket createSocket(java.net.InetAddress,int,java.net.InetAddress,int) -> createSocket
org.jivesoftware.smack.proxy.HTTPProxySocketFactory -> b.b.a.f.b:
    org.jivesoftware.smack.proxy.ProxyInfo proxy -> a
    java.util.regex.Pattern RESPONSE_PATTERN -> b
    java.net.Socket createSocket(java.lang.String,int) -> createSocket
    java.net.Socket createSocket(java.lang.String,int,java.net.InetAddress,int) -> createSocket
    java.net.Socket createSocket(java.net.InetAddress,int) -> createSocket
    java.net.Socket createSocket(java.net.InetAddress,int,java.net.InetAddress,int) -> createSocket
    java.net.Socket httpProxifiedSocket(java.lang.String,int) -> a
org.jivesoftware.smack.proxy.ProxyException -> b.b.a.f.c:
org.jivesoftware.smack.proxy.ProxyInfo -> b.b.a.f.d:
    java.lang.String proxyAddress -> a
    int proxyPort -> b
    java.lang.String proxyUsername -> c
    java.lang.String proxyPassword -> d
    org.jivesoftware.smack.proxy.ProxyInfo$ProxyType proxyType -> e
    org.jivesoftware.smack.proxy.ProxyInfo forDefaultProxy() -> a
    java.lang.String getProxyAddress() -> b
    int getProxyPort() -> c
    java.lang.String getProxyUsername() -> d
    java.lang.String getProxyPassword() -> e
    javax.net.SocketFactory getSocketFactory() -> f
org.jivesoftware.smack.proxy.ProxyInfo$ProxyType -> b.b.a.f.e:
    org.jivesoftware.smack.proxy.ProxyInfo$ProxyType NONE -> a
    org.jivesoftware.smack.proxy.ProxyInfo$ProxyType HTTP -> b
    org.jivesoftware.smack.proxy.ProxyInfo$ProxyType SOCKS4 -> c
    org.jivesoftware.smack.proxy.ProxyInfo$ProxyType SOCKS5 -> d
    org.jivesoftware.smack.proxy.ProxyInfo$ProxyType[] ENUM$VALUES -> e
    org.jivesoftware.smack.proxy.ProxyInfo$ProxyType[] values() -> values
    org.jivesoftware.smack.proxy.ProxyInfo$ProxyType valueOf(java.lang.String) -> valueOf
org.jivesoftware.smack.proxy.Socks4ProxySocketFactory -> b.b.a.f.f:
    org.jivesoftware.smack.proxy.ProxyInfo proxy -> a
    java.net.Socket createSocket(java.lang.String,int) -> createSocket
    java.net.Socket createSocket(java.lang.String,int,java.net.InetAddress,int) -> createSocket
    java.net.Socket createSocket(java.net.InetAddress,int) -> createSocket
    java.net.Socket createSocket(java.net.InetAddress,int,java.net.InetAddress,int) -> createSocket
    java.net.Socket socks4ProxifiedSocket(java.lang.String,int) -> a
org.jivesoftware.smack.proxy.Socks5ProxySocketFactory -> b.b.a.f.g:
    org.jivesoftware.smack.proxy.ProxyInfo proxy -> a
    java.net.Socket createSocket(java.lang.String,int) -> createSocket
    java.net.Socket createSocket(java.lang.String,int,java.net.InetAddress,int) -> createSocket
    java.net.Socket createSocket(java.net.InetAddress,int) -> createSocket
    java.net.Socket createSocket(java.net.InetAddress,int,java.net.InetAddress,int) -> createSocket
    java.net.Socket socks5ProxifiedSocket(java.lang.String,int) -> a
    void fill(java.io.InputStream,byte[],int) -> a
org.jivesoftware.smack.sasl.SASLAnonymous -> b.b.a.g.a:
    java.lang.String getName() -> a
    void authenticate(java.lang.String,java.lang.String,org.apache.harmony.javax.security.auth.callback.CallbackHandler) -> a
    void authenticate(java.lang.String,java.lang.String,java.lang.String) -> a
    void authenticate() -> b
    void challengeReceived(java.lang.String) -> a
org.jivesoftware.smack.sasl.SASLCramMD5Mechanism -> b.b.a.g.b:
    java.lang.String getName() -> a
org.jivesoftware.smack.sasl.SASLDigestMD5Mechanism -> b.b.a.g.c:
    java.lang.String getName() -> a
org.jivesoftware.smack.sasl.SASLExternalMechanism -> b.b.a.g.d:
    java.lang.String getName() -> a
org.jivesoftware.smack.sasl.SASLGSSAPIMechanism -> b.b.a.g.e:
    java.lang.String getName() -> a
    void authenticate(java.lang.String,java.lang.String,org.apache.harmony.javax.security.auth.callback.CallbackHandler) -> a
    void authenticate(java.lang.String,java.lang.String,java.lang.String) -> a
org.jivesoftware.smack.sasl.SASLMechanism -> b.b.a.g.f:
    org.jivesoftware.smack.SASLAuthentication saslAuthentication -> e
    org.apache.harmony.javax.security.sasl.SaslClient sc -> a
    java.lang.String authenticationId -> b
    java.lang.String password -> c
    java.lang.String hostname -> d
    void authenticate(java.lang.String,java.lang.String,java.lang.String) -> a
    void authenticate(java.lang.String,java.lang.String,org.apache.harmony.javax.security.auth.callback.CallbackHandler) -> a
    void authenticate() -> b
    void challengeReceived(java.lang.String) -> a
    java.lang.String getName() -> a
    org.jivesoftware.smack.SASLAuthentication getSASLAuthentication() -> c
    void handle(org.apache.harmony.javax.security.auth.callback.Callback[]) -> a
org.jivesoftware.smack.sasl.SASLMechanism$AuthMechanism -> b.b.a.g.g:
    java.lang.String name -> d
    java.lang.String authenticationText -> e
    org.jivesoftware.smack.sasl.SASLMechanism this$0 -> c
    java.lang.String toXML() -> f
org.jivesoftware.smack.sasl.SASLMechanism$Challenge -> b.b.a.g.h:
    java.lang.String data -> c
    java.lang.String toXML() -> f
org.jivesoftware.smack.sasl.SASLMechanism$Failure -> b.b.a.g.i:
    java.lang.String condition -> c
    java.lang.String toXML() -> f
org.jivesoftware.smack.sasl.SASLMechanism$Response -> b.b.a.g.j:
    java.lang.String authenticationText -> d
    org.jivesoftware.smack.sasl.SASLMechanism this$0 -> c
    java.lang.String toXML() -> f
org.jivesoftware.smack.sasl.SASLMechanism$Success -> b.b.a.g.k:
    java.lang.String data -> c
    java.lang.String toXML() -> f
org.jivesoftware.smack.sasl.SASLPlainMechanism -> b.b.a.g.l:
    java.lang.String getName() -> a
org.jivesoftware.smack.util.Base64 -> b.b.a.h.a:
    byte[] _STANDARD_ALPHABET -> a
    byte[] _STANDARD_DECODABET -> b
    byte[] _URL_SAFE_ALPHABET -> c
    byte[] _URL_SAFE_DECODABET -> d
    byte[] _ORDERED_ALPHABET -> e
    byte[] _ORDERED_DECODABET -> f
    byte[] getAlphabet(int) -> c
    byte[] getDecodabet(int) -> d
    byte[] encode3to4(byte[],byte[],int,int) -> b
    byte[] encode3to4(byte[],int,int,byte[],int,int) -> a
    java.lang.String encodeBytes(byte[],int,int,int) -> a
    int decode4to3(byte[],int,byte[],int,int) -> b
    byte[] decode(byte[],int,int,int) -> b
    byte[] access$0(int) -> a
    byte[] access$1(int) -> b
    int access$3(byte[],int,byte[],int,int) -> a
    byte[] access$4(byte[],byte[],int,int) -> a
org.jivesoftware.smack.util.Base64$OutputStream -> b.b.a.h.b:
    boolean encode -> a
    int position -> b
    byte[] buffer -> c
    int bufferLength -> d
    int lineLength -> e
    boolean breakLines -> f
    byte[] b4 -> g
    boolean suspendEncoding -> h
    int options -> i
    byte[] alphabet -> j
    byte[] decodabet -> k
    void write(int) -> write
    void write(byte[],int,int) -> write
    void flushBase64() -> a
    void close() -> close
org.jivesoftware.smack.util.DateFormatType -> b.b.a.h.c:
    org.jivesoftware.smack.util.DateFormatType XEP_0082_DATE_PROFILE -> a
    org.jivesoftware.smack.util.DateFormatType XEP_0082_DATETIME_PROFILE -> b
    org.jivesoftware.smack.util.DateFormatType XEP_0082_DATETIME_MILLIS_PROFILE -> c
    org.jivesoftware.smack.util.DateFormatType XEP_0082_TIME_PROFILE -> d
    org.jivesoftware.smack.util.DateFormatType XEP_0082_TIME_ZONE_PROFILE -> e
    org.jivesoftware.smack.util.DateFormatType XEP_0082_TIME_MILLIS_PROFILE -> f
    org.jivesoftware.smack.util.DateFormatType XEP_0082_TIME_MILLIS_ZONE_PROFILE -> g
    org.jivesoftware.smack.util.DateFormatType XEP_0091_DATETIME -> h
    java.lang.String formatString -> i
    org.jivesoftware.smack.util.DateFormatType[] ENUM$VALUES -> j
    java.lang.String getFormatString() -> a
    java.text.SimpleDateFormat createFormatter() -> b
    org.jivesoftware.smack.util.DateFormatType[] values() -> values
    org.jivesoftware.smack.util.DateFormatType valueOf(java.lang.String) -> valueOf
org.jivesoftware.smack.util.ObservableReader -> b.b.a.h.d:
    java.io.Reader wrappedReader -> a
    java.util.List listeners -> b
    int read(char[],int,int) -> read
    void close() -> close
    int read() -> read
    int read(char[]) -> read
    long skip(long) -> skip
    boolean ready() -> ready
    boolean markSupported() -> markSupported
    void mark(int) -> mark
    void reset() -> reset
    void addReaderListener(org.jivesoftware.smack.util.ReaderListener) -> a
    void removeReaderListener(org.jivesoftware.smack.util.ReaderListener) -> b
org.jivesoftware.smack.util.ObservableWriter -> b.b.a.h.e:
    java.io.Writer wrappedWriter -> a
    java.util.List listeners -> b
    void write(char[],int,int) -> write
    void flush() -> flush
    void close() -> close
    void write(int) -> write
    void write(char[]) -> write
    void write(java.lang.String) -> write
    void write(java.lang.String,int,int) -> write
    void notifyListeners(java.lang.String) -> a
    void addWriterListener(org.jivesoftware.smack.util.WriterListener) -> a
    void removeWriterListener(org.jivesoftware.smack.util.WriterListener) -> b
org.jivesoftware.smack.util.PacketParserUtils -> b.b.a.h.f:
    org.jivesoftware.smack.packet.Packet parseMessage(org.xmlpull.v1.XmlPullParser) -> a
    java.lang.String parseContent(org.xmlpull.v1.XmlPullParser) -> i
    org.jivesoftware.smack.packet.Presence parsePresence(org.xmlpull.v1.XmlPullParser) -> b
    org.jivesoftware.smack.packet.IQ parseIQ(org.xmlpull.v1.XmlPullParser,org.jivesoftware.smack.Connection) -> a
    org.jivesoftware.smack.packet.Authentication parseAuthentication(org.xmlpull.v1.XmlPullParser) -> j
    org.jivesoftware.smack.packet.RosterPacket parseRoster(org.xmlpull.v1.XmlPullParser) -> k
    org.jivesoftware.smack.packet.Registration parseRegistration(org.xmlpull.v1.XmlPullParser) -> l
    org.jivesoftware.smack.packet.Bind parseResourceBinding(org.xmlpull.v1.XmlPullParser) -> m
    java.util.Collection parseMechanisms(org.xmlpull.v1.XmlPullParser) -> c
    java.util.Collection parseCompressionMethods(org.xmlpull.v1.XmlPullParser) -> d
    java.util.Map parseProperties(org.xmlpull.v1.XmlPullParser) -> e
    org.jivesoftware.smack.sasl.SASLMechanism$Failure parseSASLFailure(org.xmlpull.v1.XmlPullParser) -> f
    org.jivesoftware.smack.packet.StreamError parseStreamError(org.xmlpull.v1.XmlPullParser) -> g
    org.jivesoftware.smack.packet.XMPPError parseError(org.xmlpull.v1.XmlPullParser) -> h
    org.jivesoftware.smack.packet.PacketExtension parsePacketExtension(java.lang.String,java.lang.String,org.xmlpull.v1.XmlPullParser) -> a
    java.lang.String getLanguageAttribute(org.xmlpull.v1.XmlPullParser) -> n
    java.lang.Object parseWithIntrospection(java.lang.String,java.lang.Class,org.xmlpull.v1.XmlPullParser) -> a
    java.lang.Object decode(java.lang.Class,java.lang.String) -> a
org.jivesoftware.smack.util.PacketParserUtils$1 -> b.b.a.h.g:
    java.lang.String getChildElementXML() -> d
org.jivesoftware.smack.util.PacketParserUtils$2 -> b.b.a.h.h:
    java.lang.String getChildElementXML() -> d
org.jivesoftware.smack.util.PacketParserUtils$UnparsedResultIQ -> b.b.a.h.i:
    java.lang.String str -> c
    java.lang.String getChildElementXML() -> d
org.jivesoftware.smack.util.ReaderListener -> b.b.a.h.j:
    void read(java.lang.String) -> a
org.jivesoftware.smack.util.StringUtils -> b.b.a.h.k:
    java.text.DateFormat XEP_0082_UTC_FORMAT -> a
    java.text.DateFormat dateFormatter -> b
    java.util.regex.Pattern datePattern -> c
    java.text.DateFormat timeFormatter -> d
    java.util.regex.Pattern timePattern -> e
    java.text.DateFormat timeNoZoneFormatter -> f
    java.util.regex.Pattern timeNoZonePattern -> g
    java.text.DateFormat timeNoMillisFormatter -> h
    java.util.regex.Pattern timeNoMillisPattern -> i
    java.text.DateFormat timeNoMillisNoZoneFormatter -> j
    java.util.regex.Pattern timeNoMillisNoZonePattern -> k
    java.text.DateFormat dateTimeFormatter -> l
    java.util.regex.Pattern dateTimePattern -> m
    java.text.DateFormat dateTimeNoMillisFormatter -> n
    java.util.regex.Pattern dateTimeNoMillisPattern -> o
    java.text.DateFormat xep0091Formatter -> p
    java.text.DateFormat xep0091Date6DigitFormatter -> q
    java.text.DateFormat xep0091Date7Digit1MonthFormatter -> r
    java.text.DateFormat xep0091Date7Digit2MonthFormatter -> s
    java.util.regex.Pattern xep0091Pattern -> t
    java.util.List couplings -> u
    char[] QUOTE_ENCODE -> v
    char[] APOS_ENCODE -> w
    char[] AMP_ENCODE -> x
    char[] LT_ENCODE -> y
    char[] GT_ENCODE -> z
    java.security.MessageDigest digest -> A
    java.util.Random randGen -> B
    char[] numbersAndLetters -> C
    java.util.Date parseDate(java.lang.String) -> a
    java.util.Date handleDateWithMissingLeadingZeros(java.lang.String,int) -> a
    java.util.Calendar parseXEP91Date(java.lang.String,java.text.DateFormat) -> a
    java.util.List filterDatesBefore(java.util.Calendar,java.util.Calendar[]) -> a
    java.util.Calendar determineNearestDate(java.util.Calendar,java.util.List) -> a
    java.lang.String formatXEP0082Date(java.util.Date) -> a
    java.lang.String parseName(java.lang.String) -> b
    java.lang.String parseServer(java.lang.String) -> c
    java.lang.String parseResource(java.lang.String) -> d
    java.lang.String parseBareAddress(java.lang.String) -> e
    java.lang.String escapeForXML(java.lang.String) -> f
    java.lang.String hash(java.lang.String) -> g
    java.lang.String encodeHex(byte[]) -> a
    java.lang.String encodeBase64(java.lang.String) -> h
    java.lang.String encodeBase64(byte[]) -> b
    java.lang.String encodeBase64(byte[],boolean) -> a
    java.lang.String encodeBase64(byte[],int,int,boolean) -> a
    byte[] decodeBase64(java.lang.String) -> i
    java.lang.String randomString(int) -> a
org.jivesoftware.smack.util.StringUtils$1 -> b.b.a.h.l:
    java.util.Calendar val$now -> a
    int compare(java.util.Calendar,java.util.Calendar) -> a
    int compare(java.lang.Object,java.lang.Object) -> compare
org.jivesoftware.smack.util.StringUtils$PatternCouplings -> b.b.a.h.m:
    java.util.regex.Pattern pattern -> a
    java.text.DateFormat formatter -> b
    boolean needToConvertTimeZone -> c
    java.lang.String convertTime(java.lang.String) -> a
org.jivesoftware.smack.util.WriterListener -> b.b.a.h.n:
    void write(java.lang.String) -> a
org.jivesoftware.smack.util.collections.AbstractEmptyIterator -> b.b.a.h.a.a:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    void remove() -> remove
    java.lang.Object getValue() -> a
org.jivesoftware.smack.util.collections.AbstractHashedMap -> b.b.a.h.a.b:
    java.lang.Object NULL -> a
    float loadFactor -> b
    int size -> c
    org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry[] data -> d
    int threshold -> e
    int modCount -> f
    org.jivesoftware.smack.util.collections.AbstractHashedMap$EntrySet entrySet -> g
    org.jivesoftware.smack.util.collections.AbstractHashedMap$KeySet keySet -> h
    org.jivesoftware.smack.util.collections.AbstractHashedMap$Values values -> i
    void init() -> a
    java.lang.Object get(java.lang.Object) -> get
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean containsKey(java.lang.Object) -> containsKey
    boolean containsValue(java.lang.Object) -> containsValue
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    void putAll(java.util.Map) -> putAll
    java.lang.Object remove(java.lang.Object) -> remove
    void clear() -> clear
    int hash(java.lang.Object) -> a
    boolean isEqualKey(java.lang.Object,java.lang.Object) -> a
    boolean isEqualValue(java.lang.Object,java.lang.Object) -> b
    int hashIndex(int,int) -> a
    org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry getEntry(java.lang.Object) -> b
    void updateEntry(org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry,java.lang.Object) -> a
    void addMapping(int,int,java.lang.Object,java.lang.Object) -> a
    org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry createEntry(org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry,int,java.lang.Object,java.lang.Object) -> a
    void addEntry(org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry,int) -> a
    void removeMapping(org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry,int,org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry) -> a
    void removeEntry(org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry,int,org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry) -> b
    void destroyEntry(org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry) -> a
    void checkCapacity() -> b
    void ensureCapacity(int) -> a
    int calculateNewCapacity(int) -> b
    int calculateThreshold(int,float) -> a
    org.jivesoftware.smack.util.collections.MapIterator mapIterator() -> c
    java.util.Set entrySet() -> entrySet
    java.util.Iterator createEntrySetIterator() -> d
    java.util.Set keySet() -> keySet
    java.util.Iterator createKeySetIterator() -> e
    java.util.Collection values() -> values
    java.util.Iterator createValuesIterator() -> f
    java.lang.Object clone() -> clone
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
org.jivesoftware.smack.util.collections.AbstractHashedMap$EntrySet -> b.b.a.h.a.c:
    org.jivesoftware.smack.util.collections.AbstractHashedMap parent -> a
    int size() -> size
    void clear() -> clear
    boolean remove(java.lang.Object) -> remove
    java.util.Iterator iterator() -> iterator
org.jivesoftware.smack.util.collections.AbstractHashedMap$EntrySetIterator -> b.b.a.h.a.d:
    org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry next() -> a
    java.lang.Object next() -> next
org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry -> b.b.a.h.a.e:
    org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry next -> a
    int hashCode -> b
    java.lang.Object key -> c
    java.lang.Object value -> d
    java.lang.Object getKey() -> getKey
    void setKey(java.lang.Object) -> a
    java.lang.Object getValue() -> getValue
    java.lang.Object setValue(java.lang.Object) -> setValue
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    java.lang.Object access$0(org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry) -> a
    void access$1(org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry,java.lang.Object) -> a
    void access$2(org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry,java.lang.Object) -> b
org.jivesoftware.smack.util.collections.AbstractHashedMap$HashIterator -> b.b.a.h.a.f:
    org.jivesoftware.smack.util.collections.AbstractHashedMap parent -> a
    int hashIndex -> b
    org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry last -> c
    org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry next -> d
    int expectedModCount -> e
    boolean hasNext() -> hasNext
    org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry nextEntry() -> b
    org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry currentEntry() -> c
    void remove() -> remove
    java.lang.String toString() -> toString
org.jivesoftware.smack.util.collections.AbstractHashedMap$HashMapIterator -> b.b.a.h.a.g:
    java.lang.Object next() -> next
    java.lang.Object getValue() -> a
org.jivesoftware.smack.util.collections.AbstractHashedMap$KeySet -> b.b.a.h.a.h:
    org.jivesoftware.smack.util.collections.AbstractHashedMap parent -> a
    int size() -> size
    void clear() -> clear
    boolean contains(java.lang.Object) -> contains
    boolean remove(java.lang.Object) -> remove
    java.util.Iterator iterator() -> iterator
org.jivesoftware.smack.util.collections.AbstractHashedMap$KeySetIterator -> b.b.a.h.a.i:
    java.lang.Object next() -> next
org.jivesoftware.smack.util.collections.AbstractHashedMap$Values -> b.b.a.h.a.j:
    org.jivesoftware.smack.util.collections.AbstractHashedMap parent -> a
    int size() -> size
    void clear() -> clear
    boolean contains(java.lang.Object) -> contains
    java.util.Iterator iterator() -> iterator
org.jivesoftware.smack.util.collections.AbstractHashedMap$ValuesIterator -> b.b.a.h.a.k:
    java.lang.Object next() -> next
org.jivesoftware.smack.util.collections.AbstractKeyValue -> b.b.a.h.a.l:
    java.lang.Object key -> a
    java.lang.Object value -> b
    java.lang.Object getKey() -> getKey
    java.lang.Object getValue() -> getValue
    java.lang.String toString() -> toString
org.jivesoftware.smack.util.collections.AbstractMapEntry -> b.b.a.h.a.m:
    java.lang.Object setValue(java.lang.Object) -> setValue
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
org.jivesoftware.smack.util.collections.AbstractReferenceMap -> b.b.a.h.a.n:
    int keyType -> j
    int valueType -> k
    boolean purgeValues -> l
    java.lang.ref.ReferenceQueue queue -> m
    void init() -> a
    void verify(java.lang.String,int) -> a
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean containsKey(java.lang.Object) -> containsKey
    boolean containsValue(java.lang.Object) -> containsValue
    java.lang.Object get(java.lang.Object) -> get
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    java.lang.Object remove(java.lang.Object) -> remove
    void clear() -> clear
    org.jivesoftware.smack.util.collections.MapIterator mapIterator() -> c
    java.util.Set entrySet() -> entrySet
    java.util.Set keySet() -> keySet
    java.util.Collection values() -> values
    void purgeBeforeRead() -> g
    void purgeBeforeWrite() -> h
    void purge() -> i
    void purge(java.lang.ref.Reference) -> a
    org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry getEntry(java.lang.Object) -> b
    int hashEntry(java.lang.Object,java.lang.Object) -> c
    boolean isEqualKey(java.lang.Object,java.lang.Object) -> a
    org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry createEntry(org.jivesoftware.smack.util.collections.AbstractHashedMap$HashEntry,int,java.lang.Object,java.lang.Object) -> a
    java.util.Iterator createEntrySetIterator() -> d
    java.util.Iterator createKeySetIterator() -> e
    java.util.Iterator createValuesIterator() -> f
    java.lang.ref.ReferenceQueue access$0(org.jivesoftware.smack.util.collections.AbstractReferenceMap) -> a
org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceEntry -> b.b.a.h.a.o:
    org.jivesoftware.smack.util.collections.AbstractReferenceMap parent -> c
    java.lang.ref.Reference refKey -> d
    java.lang.ref.Reference refValue -> e
    java.lang.Object getKey() -> getKey
    java.lang.Object getValue() -> getValue
    java.lang.Object setValue(java.lang.Object) -> setValue
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.ref.Reference toReference(int,java.lang.Object,int) -> a
    boolean purge(java.lang.ref.Reference) -> a
    org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceEntry next() -> a
org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceEntrySet -> b.b.a.h.a.p:
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceEntrySetIterator -> b.b.a.h.a.q:
    org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceEntry next() -> a
    java.lang.Object next() -> next
org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceIteratorBase -> b.b.a.h.a.r:
    org.jivesoftware.smack.util.collections.AbstractReferenceMap parent -> a
    int index -> b
    org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceEntry entry -> c
    org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceEntry previous -> d
    java.lang.Object nextKey -> e
    java.lang.Object nextValue -> f
    java.lang.Object currentKey -> g
    java.lang.Object currentValue -> h
    int expectedModCount -> i
    boolean hasNext() -> hasNext
    void checkMod() -> a
    boolean nextNull() -> e
    org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceEntry nextEntry() -> b
    org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceEntry currentEntry() -> c
    org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceEntry superNext() -> d
    void remove() -> remove
org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceKeySet -> b.b.a.h.a.s:
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceKeySetIterator -> b.b.a.h.a.t:
    java.lang.Object next() -> next
org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceMapIterator -> b.b.a.h.a.u:
    java.lang.Object next() -> next
    java.lang.Object getValue() -> a
org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceValues -> b.b.a.h.a.v:
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
org.jivesoftware.smack.util.collections.AbstractReferenceMap$ReferenceValuesIterator -> b.b.a.h.a.w:
    java.lang.Object next() -> next
org.jivesoftware.smack.util.collections.AbstractReferenceMap$SoftRef -> b.b.a.h.a.x:
    int hash -> a
    int hashCode() -> hashCode
org.jivesoftware.smack.util.collections.AbstractReferenceMap$WeakRef -> b.b.a.h.a.y:
    int hash -> a
    int hashCode() -> hashCode
org.jivesoftware.smack.util.collections.DefaultMapEntry -> b.b.a.h.a.z:
org.jivesoftware.smack.util.collections.EmptyIterator -> b.b.a.h.a.aa:
    org.jivesoftware.smack.util.collections.ResettableIterator RESETTABLE_INSTANCE -> a
    java.util.Iterator INSTANCE -> b
    java.lang.Object getValue() -> a
    java.lang.Object next() -> next
    void remove() -> remove
    boolean hasNext() -> hasNext
org.jivesoftware.smack.util.collections.EmptyMapIterator -> b.b.a.h.a.ab:
    org.jivesoftware.smack.util.collections.MapIterator INSTANCE -> a
    java.lang.Object getValue() -> a
    java.lang.Object next() -> next
    void remove() -> remove
    boolean hasNext() -> hasNext
org.jivesoftware.smack.util.collections.IterableMap -> b.b.a.h.a.ac:
org.jivesoftware.smack.util.collections.MapIterator -> b.b.a.h.a.ad:
    boolean hasNext() -> hasNext
    java.lang.Object next() -> next
    java.lang.Object getValue() -> a
org.jivesoftware.smack.util.collections.ReferenceMap -> b.b.a.h.a.ae:
org.jivesoftware.smack.util.collections.ResettableIterator -> b.b.a.h.a.af:
org.jivesoftware.smack.util.dns.HostAddress -> b.b.a.h.b.a:
    java.lang.String fqdn -> a
    int port -> b
    java.lang.Exception exception -> c
    java.lang.String getFQDN() -> a
    int getPort() -> b
    void setException(java.lang.Exception) -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
    java.lang.String getErrorMessage() -> c
org.jivesoftware.smackx.ChatState -> b.b.b.a:
    org.jivesoftware.smackx.ChatState active -> a
    org.jivesoftware.smackx.ChatState composing -> b
    org.jivesoftware.smackx.ChatState paused -> c
    org.jivesoftware.smackx.ChatState inactive -> d
    org.jivesoftware.smackx.ChatState gone -> e
    org.jivesoftware.smackx.ChatState[] ENUM$VALUES -> f
    org.jivesoftware.smackx.ChatState[] values() -> values
    org.jivesoftware.smackx.ChatState valueOf(java.lang.String) -> valueOf
org.jivesoftware.smackx.packet.ChatStateExtension -> b.b.b.a.a:
    org.jivesoftware.smackx.ChatState state -> a
    java.lang.String getElementName() -> a
    java.lang.String getNamespace() -> c
    java.lang.String toXML() -> b
org.jivesoftware.smackx.packet.ChatStateExtension$Provider -> b.b.b.a.b:
    org.jivesoftware.smack.packet.PacketExtension parseExtension(org.xmlpull.v1.XmlPullParser) -> a
org.jivesoftware.smackx.packet.DelayInfo -> b.b.b.a.c:
    org.jivesoftware.smackx.packet.DelayInformation wrappedInfo -> a
    java.lang.String getFrom() -> c
    java.lang.String getReason() -> d
    java.util.Date getStamp() -> e
    void setFrom(java.lang.String) -> a
    void setReason(java.lang.String) -> b
    java.lang.String getElementName() -> a
    java.lang.String getNamespace() -> f
    java.lang.String toXML() -> b
org.jivesoftware.smackx.packet.DelayInformation -> b.b.b.a.d:
    java.text.DateFormat XEP_0091_UTC_FORMAT -> b
    java.util.Date stamp -> a
    java.lang.String from -> c
    java.lang.String reason -> d
    java.lang.String getFrom() -> c
    void setFrom(java.lang.String) -> a
    java.util.Date getStamp() -> e
    java.lang.String getReason() -> d
    void setReason(java.lang.String) -> b
    java.lang.String getElementName() -> a
    java.lang.String getNamespace() -> f
    java.lang.String toXML() -> b
org.jivesoftware.smackx.packet.DiscoverInfo -> b.b.b.a.e:
    java.util.List features -> c
    java.util.List identities -> d
    java.lang.String node -> e
    void addFeature(java.lang.String) -> a
    void addFeature(org.jivesoftware.smackx.packet.DiscoverInfo$Feature) -> a
    void addIdentity(org.jivesoftware.smackx.packet.DiscoverInfo$Identity) -> a
    java.lang.String getNode() -> a
    void setNode(java.lang.String) -> b
    java.lang.String getChildElementXML() -> d
org.jivesoftware.smackx.packet.DiscoverInfo$Feature -> b.b.b.a.f:
    java.lang.String variable -> a
    java.lang.String toXML() -> a
    boolean equals(java.lang.Object) -> equals
org.jivesoftware.smackx.packet.DiscoverInfo$Identity -> b.b.b.a.g:
    java.lang.String category -> a
    java.lang.String name -> b
    java.lang.String type -> c
    java.lang.String lang -> d
    void setLanguage(java.lang.String) -> a
    java.lang.String toXML() -> a
    boolean equals(java.lang.Object) -> equals
    int compareTo(java.lang.Object) -> compareTo
org.jivesoftware.smackx.packet.DiscoverItems -> b.b.b.a.h:
    java.util.List items -> c
    java.lang.String node -> d
    void addItem(org.jivesoftware.smackx.packet.DiscoverItems$Item) -> a
    java.lang.String getNode() -> a
    void setNode(java.lang.String) -> a
    java.lang.String getChildElementXML() -> d
org.jivesoftware.smackx.packet.DiscoverItems$Item -> b.b.b.a.i:
    java.lang.String entityID -> a
    java.lang.String name -> b
    java.lang.String node -> c
    java.lang.String action -> d
    void setName(java.lang.String) -> a
    void setNode(java.lang.String) -> b
    void setAction(java.lang.String) -> c
    java.lang.String toXML() -> a
org.jivesoftware.smackx.packet.VCard -> b.b.b.a.j:
    java.util.Map homePhones -> c
    java.util.Map workPhones -> d
    java.util.Map homeAddr -> e
    java.util.Map workAddr -> f
    java.lang.String firstName -> g
    java.lang.String lastName -> h
    java.lang.String middleName -> i
    java.lang.String emailHome -> j
    java.lang.String emailWork -> k
    java.lang.String organization -> l
    java.lang.String organizationUnit -> m
    java.lang.String avatar -> n
    java.util.Map otherSimpleFields -> o
    java.util.Map otherUnescapableFields -> p
    void setField(java.lang.String,java.lang.String) -> a
    void setField(java.lang.String,java.lang.String,boolean) -> a
    void setFirstName(java.lang.String) -> a
    void setLastName(java.lang.String) -> b
    void setMiddleName(java.lang.String) -> c
    void setNickName(java.lang.String) -> d
    void setEmailHome(java.lang.String) -> e
    void setEmailWork(java.lang.String) -> f
    void setOrganization(java.lang.String) -> k
    void setOrganizationUnit(java.lang.String) -> l
    void setAddressFieldHome(java.lang.String,java.lang.String) -> b
    void setAddressFieldWork(java.lang.String,java.lang.String) -> c
    void setPhoneHome(java.lang.String,java.lang.String) -> d
    void setPhoneWork(java.lang.String,java.lang.String) -> e
    void setEncodedImage(java.lang.String) -> m
    void updateFN() -> a
    void save(org.jivesoftware.smack.Connection) -> a
    void load(org.jivesoftware.smack.Connection) -> b
    void doLoad(org.jivesoftware.smack.Connection,java.lang.String) -> a
    java.lang.String getChildElementXML() -> d
    void copyFieldsFrom(org.jivesoftware.smackx.packet.VCard) -> q
    void checkAuthenticated(org.jivesoftware.smack.Connection,boolean) -> a
    boolean hasContent() -> b
    boolean hasNameField() -> c
    boolean hasOrganizationFields() -> g
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean access$0(org.jivesoftware.smackx.packet.VCard) -> a
    boolean access$1(org.jivesoftware.smackx.packet.VCard) -> b
    java.lang.String access$2(org.jivesoftware.smackx.packet.VCard) -> c
    java.lang.String access$3(org.jivesoftware.smackx.packet.VCard) -> d
    java.util.Map access$4(org.jivesoftware.smackx.packet.VCard) -> e
    java.util.Map access$5(org.jivesoftware.smackx.packet.VCard) -> f
    java.util.Map access$6(org.jivesoftware.smackx.packet.VCard) -> g
    java.util.Map access$7(org.jivesoftware.smackx.packet.VCard) -> h
    java.util.Map access$8(org.jivesoftware.smackx.packet.VCard) -> i
    java.util.Map access$9(org.jivesoftware.smackx.packet.VCard) -> j
    boolean access$10(org.jivesoftware.smackx.packet.VCard) -> k
    java.lang.String access$11(org.jivesoftware.smackx.packet.VCard) -> l
    java.lang.String access$12(org.jivesoftware.smackx.packet.VCard) -> m
    java.lang.String access$13(org.jivesoftware.smackx.packet.VCard) -> n
    java.lang.String access$14(org.jivesoftware.smackx.packet.VCard) -> o
    java.lang.String access$15(org.jivesoftware.smackx.packet.VCard) -> p
org.jivesoftware.smackx.packet.VCard$ContentBuilder -> b.b.b.a.k:
    void addTagContent() -> a
org.jivesoftware.smackx.packet.VCard$VCardWriter -> b.b.b.a.l:
    java.lang.StringBuilder sb -> b
    org.jivesoftware.smackx.packet.VCard this$0 -> a
    void write() -> a
    void buildActualContent() -> b
    void appendEmail(java.lang.String,java.lang.String) -> a
    void appendPhones(java.util.Map,java.lang.String) -> a
    void appendAddress(java.util.Map,java.lang.String) -> b
    void appendEmptyTag(java.lang.Object) -> a
    void appendGenericFields() -> c
    void appendOrganization() -> d
    void appendN() -> e
    void appendTag(java.lang.String,java.lang.String,java.lang.String,boolean,org.jivesoftware.smackx.packet.VCard$ContentBuilder) -> a
    void appendTag(java.lang.String,boolean,org.jivesoftware.smackx.packet.VCard$ContentBuilder) -> a
    void appendTag(java.lang.String,java.lang.String) -> b
    void access$0(org.jivesoftware.smackx.packet.VCard$VCardWriter) -> a
    void access$1(org.jivesoftware.smackx.packet.VCard$VCardWriter,java.lang.Object) -> a
    void access$2(org.jivesoftware.smackx.packet.VCard$VCardWriter,java.lang.String,java.lang.String) -> a
    java.lang.StringBuilder access$3(org.jivesoftware.smackx.packet.VCard$VCardWriter) -> b
    org.jivesoftware.smackx.packet.VCard access$4(org.jivesoftware.smackx.packet.VCard$VCardWriter) -> c
org.jivesoftware.smackx.packet.VCard$VCardWriter$1 -> b.b.b.a.m:
    org.jivesoftware.smackx.packet.VCard$VCardWriter this$1 -> a
    void addTagContent() -> a
org.jivesoftware.smackx.packet.VCard$VCardWriter$2 -> b.b.b.a.n:
    org.jivesoftware.smackx.packet.VCard$VCardWriter this$1 -> a
    java.lang.String val$type -> b
    java.lang.String val$email -> c
    void addTagContent() -> a
org.jivesoftware.smackx.packet.VCard$VCardWriter$3 -> b.b.b.a.o:
    org.jivesoftware.smackx.packet.VCard$VCardWriter this$1 -> a
    java.util.Map$Entry val$entry -> b
    java.lang.String val$code -> c
    void addTagContent() -> a
org.jivesoftware.smackx.packet.VCard$VCardWriter$4 -> b.b.b.a.p:
    org.jivesoftware.smackx.packet.VCard$VCardWriter this$1 -> a
    java.lang.String val$code -> b
    java.util.Map val$addr -> c
    void addTagContent() -> a
org.jivesoftware.smackx.packet.VCard$VCardWriter$5 -> b.b.b.a.q:
    org.jivesoftware.smackx.packet.VCard$VCardWriter this$1 -> a
    void addTagContent() -> a
org.jivesoftware.smackx.packet.VCard$VCardWriter$6 -> b.b.b.a.r:
    org.jivesoftware.smackx.packet.VCard$VCardWriter this$1 -> a
    void addTagContent() -> a
org.jivesoftware.smackx.packet.VCard$VCardWriter$7 -> b.b.b.a.s:
    org.jivesoftware.smackx.packet.VCard$VCardWriter this$1 -> a
    java.lang.String val$tagText -> b
    void addTagContent() -> a
org.jivesoftware.smackx.provider.DelayInfoProvider -> b.b.b.b.a:
    org.jivesoftware.smack.packet.PacketExtension parseExtension(org.xmlpull.v1.XmlPullParser) -> a
org.jivesoftware.smackx.provider.DelayInformationProvider -> b.b.b.b.b:
    org.jivesoftware.smack.packet.PacketExtension parseExtension(org.xmlpull.v1.XmlPullParser) -> a
org.jivesoftware.smackx.provider.DiscoverInfoProvider -> b.b.b.b.c:
    org.jivesoftware.smack.packet.IQ parseIQ(org.xmlpull.v1.XmlPullParser) -> a
org.jivesoftware.smackx.provider.DiscoverItemsProvider -> b.b.b.b.d:
    org.jivesoftware.smack.packet.IQ parseIQ(org.xmlpull.v1.XmlPullParser) -> a
org.jivesoftware.smackx.provider.EmbeddedExtensionProvider -> b.b.b.b.e:
    org.jivesoftware.smack.packet.PacketExtension parseExtension(org.xmlpull.v1.XmlPullParser) -> a
    org.jivesoftware.smack.packet.PacketExtension createReturnExtension(java.lang.String,java.lang.String,java.util.Map,java.util.List) -> a
org.jivesoftware.smackx.provider.VCardProvider -> b.b.b.b.f:
    org.jivesoftware.smack.packet.IQ parseIQ(org.xmlpull.v1.XmlPullParser) -> a
    org.jivesoftware.smackx.packet.VCard createVCardFromXML(java.lang.String) -> a
org.jivesoftware.smackx.provider.VCardProvider$VCardReader -> b.b.b.b.g:
    org.jivesoftware.smackx.packet.VCard vCard -> a
    org.w3c.dom.Document document -> b
    void initializeFields() -> a
    void setupEmails() -> b
    void setupPhones() -> c
    boolean isWorkHome(java.lang.String) -> a
    void setupAddresses() -> d
    java.lang.String getTagContents(java.lang.String) -> b
    void setupSimpleFields() -> e
    java.lang.String getTextContent(org.w3c.dom.Node) -> a
    void appendText(java.lang.StringBuilder,org.w3c.dom.Node) -> a
org.jivesoftware.smackx.pubsub.EmbeddedPacketExtension -> b.b.b.c.a:
org.jivesoftware.smackx.pubsub.EventElement -> b.b.b.c.b:
    org.jivesoftware.smackx.pubsub.EventElementType type -> a
    org.jivesoftware.smackx.pubsub.NodeExtension ext -> b
    java.lang.String getElementName() -> a
    java.lang.String toXML() -> b
org.jivesoftware.smackx.pubsub.EventElementType -> b.b.b.c.c:
    org.jivesoftware.smackx.pubsub.EventElementType collection -> a
    org.jivesoftware.smackx.pubsub.EventElementType configuration -> b
    org.jivesoftware.smackx.pubsub.EventElementType delete -> c
    org.jivesoftware.smackx.pubsub.EventElementType items -> d
    org.jivesoftware.smackx.pubsub.EventElementType purge -> e
    org.jivesoftware.smackx.pubsub.EventElementType subscription -> f
    org.jivesoftware.smackx.pubsub.EventElementType[] ENUM$VALUES -> g
    org.jivesoftware.smackx.pubsub.EventElementType[] values() -> values
    org.jivesoftware.smackx.pubsub.EventElementType valueOf(java.lang.String) -> valueOf
org.jivesoftware.smackx.pubsub.Item -> b.b.b.c.d:
    java.lang.String id -> a
    java.lang.String getId() -> c
    java.lang.String toXML() -> b
    java.lang.String toString() -> toString
org.jivesoftware.smackx.pubsub.ItemsExtension -> b.b.b.c.e:
    org.jivesoftware.smackx.pubsub.ItemsExtension$ItemsElementType type -> a
    java.lang.Boolean notify -> b
    java.util.List items -> c
    java.lang.String toXML() -> b
    java.lang.String toString() -> toString
org.jivesoftware.smackx.pubsub.ItemsExtension$ItemsElementType -> b.b.b.c.f:
    org.jivesoftware.smackx.pubsub.ItemsExtension$ItemsElementType items -> a
    org.jivesoftware.smackx.pubsub.ItemsExtension$ItemsElementType retract -> b
    org.jivesoftware.smackx.pubsub.PubSubElementType elem -> c
    java.lang.String att -> d
    org.jivesoftware.smackx.pubsub.ItemsExtension$ItemsElementType[] ENUM$VALUES -> e
    org.jivesoftware.smackx.pubsub.PubSubElementType getNodeElement() -> a
    java.lang.String getElementAttribute() -> b
    org.jivesoftware.smackx.pubsub.ItemsExtension$ItemsElementType[] values() -> values
    org.jivesoftware.smackx.pubsub.ItemsExtension$ItemsElementType valueOf(java.lang.String) -> valueOf
org.jivesoftware.smackx.pubsub.NodeExtension -> b.b.b.c.g:
    org.jivesoftware.smackx.pubsub.PubSubElementType element -> a
    java.lang.String node -> b
    java.lang.String getNode() -> d
    java.lang.String getElementName() -> a
    java.lang.String toXML() -> b
    java.lang.String toString() -> toString
org.jivesoftware.smackx.pubsub.PayloadItem -> b.b.b.c.h:
    org.jivesoftware.smack.packet.PacketExtension payload -> a
    java.lang.String toXML() -> b
    java.lang.String toString() -> toString
org.jivesoftware.smackx.pubsub.PubSubElementType -> b.b.b.c.i:
    org.jivesoftware.smackx.pubsub.PubSubElementType CREATE -> a
    org.jivesoftware.smackx.pubsub.PubSubElementType DELETE -> b
    org.jivesoftware.smackx.pubsub.PubSubElementType DELETE_EVENT -> c
    org.jivesoftware.smackx.pubsub.PubSubElementType CONFIGURE -> d
    org.jivesoftware.smackx.pubsub.PubSubElementType CONFIGURE_OWNER -> e
    org.jivesoftware.smackx.pubsub.PubSubElementType CONFIGURATION -> f
    org.jivesoftware.smackx.pubsub.PubSubElementType OPTIONS -> g
    org.jivesoftware.smackx.pubsub.PubSubElementType DEFAULT -> h
    org.jivesoftware.smackx.pubsub.PubSubElementType ITEMS -> i
    org.jivesoftware.smackx.pubsub.PubSubElementType ITEMS_EVENT -> j
    org.jivesoftware.smackx.pubsub.PubSubElementType ITEM -> k
    org.jivesoftware.smackx.pubsub.PubSubElementType ITEM_EVENT -> l
    org.jivesoftware.smackx.pubsub.PubSubElementType PUBLISH -> m
    org.jivesoftware.smackx.pubsub.PubSubElementType PUBLISH_OPTIONS -> n
    org.jivesoftware.smackx.pubsub.PubSubElementType PURGE_OWNER -> o
    org.jivesoftware.smackx.pubsub.PubSubElementType PURGE_EVENT -> p
    org.jivesoftware.smackx.pubsub.PubSubElementType RETRACT -> q
    org.jivesoftware.smackx.pubsub.PubSubElementType AFFILIATIONS -> r
    org.jivesoftware.smackx.pubsub.PubSubElementType SUBSCRIBE -> s
    org.jivesoftware.smackx.pubsub.PubSubElementType SUBSCRIPTION -> t
    org.jivesoftware.smackx.pubsub.PubSubElementType SUBSCRIPTIONS -> u
    org.jivesoftware.smackx.pubsub.PubSubElementType UNSUBSCRIBE -> v
    java.lang.String eName -> w
    org.jivesoftware.smackx.pubsub.packet.PubSubNamespace nSpace -> x
    org.jivesoftware.smackx.pubsub.PubSubElementType[] ENUM$VALUES -> y
    java.lang.String getElementName() -> a
    org.jivesoftware.smackx.pubsub.PubSubElementType[] values() -> values
    org.jivesoftware.smackx.pubsub.PubSubElementType valueOf(java.lang.String) -> valueOf
org.jivesoftware.smackx.pubsub.SimplePayload -> b.b.b.c.j:
    java.lang.String elemName -> a
    java.lang.String ns -> b
    java.lang.String payload -> c
    java.lang.String getElementName() -> a
    java.lang.String toXML() -> b
    java.lang.String toString() -> toString
org.jivesoftware.smackx.pubsub.packet.PubSub -> b.b.b.c.a.a:
    org.jivesoftware.smackx.pubsub.packet.PubSubNamespace ns -> c
    java.lang.String getElementName() -> a
    java.lang.String getNamespace() -> b
    void setPubSubNamespace(org.jivesoftware.smackx.pubsub.packet.PubSubNamespace) -> a
    java.lang.String getChildElementXML() -> d
org.jivesoftware.smackx.pubsub.packet.PubSubNamespace -> b.b.b.c.a.b:
    org.jivesoftware.smackx.pubsub.packet.PubSubNamespace BASIC -> a
    org.jivesoftware.smackx.pubsub.packet.PubSubNamespace ERROR -> b
    org.jivesoftware.smackx.pubsub.packet.PubSubNamespace EVENT -> c
    org.jivesoftware.smackx.pubsub.packet.PubSubNamespace OWNER -> d
    java.lang.String fragment -> e
    org.jivesoftware.smackx.pubsub.packet.PubSubNamespace[] ENUM$VALUES -> f
    java.lang.String getXmlns() -> a
    org.jivesoftware.smackx.pubsub.packet.PubSubNamespace valueOfFromXmlns(java.lang.String) -> a
    org.jivesoftware.smackx.pubsub.packet.PubSubNamespace[] values() -> values
    org.jivesoftware.smackx.pubsub.packet.PubSubNamespace valueOf(java.lang.String) -> valueOf
org.jivesoftware.smackx.pubsub.provider.EventProvider -> b.b.b.c.b.a:
    org.jivesoftware.smack.packet.PacketExtension createReturnExtension(java.lang.String,java.lang.String,java.util.Map,java.util.List) -> a
org.jivesoftware.smackx.pubsub.provider.ItemProvider -> b.b.b.c.b.b:
    org.jivesoftware.smack.packet.PacketExtension parseExtension(org.xmlpull.v1.XmlPullParser) -> a
org.jivesoftware.smackx.pubsub.provider.ItemsProvider -> b.b.b.c.b.c:
    org.jivesoftware.smack.packet.PacketExtension createReturnExtension(java.lang.String,java.lang.String,java.util.Map,java.util.List) -> a
org.jivesoftware.smackx.pubsub.provider.PubSubProvider -> b.b.b.c.b.d:
    org.jivesoftware.smack.packet.IQ parseIQ(org.xmlpull.v1.XmlPullParser) -> a
